

2014-02-11 02:00                                                                            main.c                                                                            Page 1


/*											  static void free_tokens (argtok_s *list);
 main.c											  
 Author: Jonathan Hamm									  static int check_mode_c (char c);
											  static int check_mode_w (char *w);
 Description:										  
    Contains main function. This simply parses the command line				  static files_s argsparse_start (argtok_s **curr);
    arguments supplied by the user, and invokes the compiler				  static void argparse_actionlist (argtok_s **curr, files_s *parent);
    accordingly.									  static void argparse_type (argtok_s **curr, files_s *parent);
 */											  static const char **argparse_char (argtok_s **curr, files_s *parent);
											  static const char **argparse_word (argtok_s **curr, files_s *parent);
#include "lex.h"									  
#include "parse.h"									  static void print_usage (const char *message, const char *curr);
#include "general.h"									  
#include <stdio.h>									  int main(int argc, const char *argv[])
#include <stdlib.h>									  {
#include <string.h>									      char *outname, *scopename;
											      files_s files;
enum term_args_ {									      argtok_s *list;
    ARG_CHAR,										      lextok_s lextok;
    ARG_WORD,										      parse_s *p;
    ARG_DASH,										      FILE *gen, *scope;
    ARG_ASSIGN,										  
    ARG_EOF										      list = arg_tokenize(argc, argv);
};											      files = argsparse_start(&list);
											      free_tokens(list);
#define DEFAULT_REGEX	"regex_pascal"							      lextok = lexf(buildlex(files.regex), readfile(files.source), 0, true);
#define DEFAULT_CFG	"cfg_pascal"							      p = build_parse(files.cfg, lextok);
#define DEFAULT_SOURCE	"samples/smallworking.pas"					  
											      outname = malloc(strlen(files.source)+5);
#define COMP_HELP	"Usage: \n" \							      if(!outname) {
			"pc [--help] [<sourcefile>] [-s <sourcefile> | --source=<sourcefi 	  perror("Memory Allocation Error");
			"[-r <regexfile> | --regex=<regexfile>] [-p <cfgfile> | --cfg=<cf 	  exit(EXIT_FAILURE);
			"%-20sPrints this Message\n" \					      }
			"%-20sSpecify Regex File\n" \					      sprintf(outname, "%s.tac", files.source);
			"%-20sSpecify File Containing Language's Backus-Naur Form\n" \	      gen = fopen(outname, "w");
			"%-20sSpecify Source File"					      if(!gen){
											  	  perror("Error Creating File");
typedef struct argtok_s argtok_s;							  	  exit(EXIT_FAILURE);
typedef struct files_s files_s;								      }
											  
struct argtok_s										      scopename = malloc(strlen(files.source)+7);
{											      if(!scopename) {
    int id;										  	  perror("Memory Allocation Error");
    char *lexeme;									  	  exit(EXIT_FAILURE);
    argtok_s *next;									      }
};											      sprintf(scopename, "%s.scope", files.source);
											      scope = fopen(scopename, "w");
struct files_s										      if(!scope){
{											  	  perror("Error Creating File");
    const char *regex;									  	  exit(EXIT_FAILURE);
    const char *cfg;									      }
    const char *source;									  
};											      parse(p, lextok, gen);
											      print_listing(p->listing, stdout);
static void add_argtoken (argtok_s **tlist, const char *lexeme, int id);		      free_listing(p->listing);
static argtok_s *arg_tokenize (int argc, const char *argv[]);				      print_scope(scope);







2014-02-11 02:00                                                                            main.c                                                                            Page 2


    fclose(gen);									  			  while ((c = *argv[i])) {
    fclose(scope);									  			      if (c == '-' || c == '=') {
    free(outname);									  				  allocated = malloc(argv[i] - startptr + 1);
    return 0;										  				  if (!allocated) {
}											  				      perror("Memory Allocation Error");
											  				      exit(EXIT_FAILURE);
void add_argtoken (argtok_s **tlist, const char *lexeme, int id)			  				  }
{											  				  strncpy(allocated, startptr, argv[i] - startptr);
    argtok_s *tok;									  				  allocated[argv[i] - startptr] = '\0';
											  				  startptr = allocated;
    tok = malloc(sizeof(*tok));								  				  break;
    if (!tok) {										  			      }
	perror("Memory Allocation Error");						  			      if (c == '\\') {
	exit(EXIT_FAILURE);								  				  argv[i]++;
    }											  				  if (!argv[i]) {
    tok->id = id;									  				      print_usage("Error: Dangling Backslash", NULL);
    tok->next = NULL;									  				      exit(EXIT_FAILURE);
    tok->lexeme = (char *)lexeme;							  				  }
    if (*tlist)										  			      }
	(*tlist)->next = tok;								  			      argv[i]++;
    *tlist = tok;									  			  }
}											  			  add_argtoken (&tlist, startptr, ARG_WORD);
											  			  if (!head)
argtok_s *arg_tokenize (int argc, const char *argv[])					  			      head = tlist;
{											  		      }
    int i;										  		      else {
    char c;										  			  add_argtoken (&tlist, startptr, ARG_CHAR);
    char *allocated;									  			  if (!head)
    const char *startptr;								  			      head = tlist;
    argtok_s *head = NULL, *tlist = NULL;						  		      }
											  		      break;
    if (argc == 1)									  	      }
	return NULL;									  	  }
    for (i = 1; i < argc; i++) {							      }
	while ((c = *argv[i])) {							      add_argtoken(&tlist, "$", ARG_EOF);
	    switch (c) {								      return head;
		case '-':								  }
		    add_argtoken (&tlist, "-", ARG_DASH);				  
		    if (!head)								  void free_tokens (argtok_s *list)
			head = tlist;							  {
		    argv[i]++;								      argtok_s *backup;
		    break;								  
		case '=':								      while (list) {
		    add_argtoken (&tlist, "=", ARG_ASSIGN);				  	  backup = list;
		    if (!head)								  	  if (is_allocated(list->lexeme))
			head = tlist;							  	      free(list->lexeme);
		    argv[i]++;								  	  list = list->next;
		    break;								  	  free(backup);
		case '\\':								      }
		    if (!++argv[i]) {							  }
			print_usage("Error: Dangling Backslash", NULL);			  
			exit(EXIT_FAILURE);						  files_s argsparse_start (argtok_s **curr)
		    }									  {
		default:								      files_s files = (files_s){NULL, NULL, NULL};
		    startptr = argv[i];							  
		    if (*++argv[i]) {							      if (!*curr)







2014-02-11 02:00                                                                            main.c                                                                            Page 3


	return (files_s){.regex = DEFAULT_REGEX, .cfg = DEFAULT_CFG, .source = DEFAULT_SO 	      *curr = (*curr)->next;
    argparse_actionlist(curr, &files);							  	      if ((*curr)->id == ARG_ASSIGN)
    if ((*curr)->id == ARG_EOF) {							  		  break;
	if (!files.regex)								  	      else {
	    files.regex = DEFAULT_REGEX;						  		  print_usage("Syntax Error: Expected '=' but got %s", (*curr)->lexeme);
	if (!files.cfg)									  		  exit(EXIT_FAILURE);
	    files.cfg = DEFAULT_CFG;							  	      }
	if (!files.source)								  	      break;
	    files.source = DEFAULT_SOURCE;						  	  default:
	return files;									  	      print_usage("Syntax Error: Expected '-' or character but got %s", (*curr)->le
    }											  	      exit(EXIT_FAILURE);
    else {										  	      break;
	print_usage("Syntax Error: Extra Token %s", (*curr)->lexeme);			      }
	exit(EXIT_FAILURE);								      *curr = (*curr)->next;
    }											      if (*assign) {
}											  	  print_usage("Error: Property Already Assigned", NULL);
											  	  exit(EXIT_FAILURE);
void argparse_actionlist (argtok_s **curr, files_s *parent)				      }
{											      if ((*curr)->id == ARG_WORD || (*curr)->id == ARG_CHAR) {
    switch ((*curr)->id) {								  	  *assign = (*curr)->lexeme;
	case ARG_DASH:									  	  *curr = (*curr)->next;
	    *curr = (*curr)->next;							      }
	    argparse_type(curr, parent);						      else {
	    argparse_actionlist(curr, parent);						  	  print_usage("Error: Invalid File Name: %s", (*curr)->lexeme);
	    break;									  	  exit(EXIT_FAILURE);
	case ARG_CHAR:									      }
	case ARG_WORD:									  }
	    if (!parent->source)							  
		parent->source = (*curr)->lexeme;					  const char **argparse_char (argtok_s **curr, files_s *parent)
	    else {									  {
		printf("Error: Source File Already Specified");				      switch (*(*curr)->lexeme) {
		exit(EXIT_FAILURE);							  	  case 'p':
	    }										  	  case 'P':
	    *curr = (*curr)->next;							  	      return &parent->cfg;
	    argparse_actionlist(curr, parent);						  	  case 'r':
	    break;									  	  case 'R':
	case ARG_EOF:									  	      return &parent->regex;
	    break;									  	  case 's':
	default:									  	  case 'S':
	    print_usage("Syntax Error: Expected '-' or word but got %s", (*curr)->lexeme) 	      return &parent->source;
	    exit(EXIT_FAILURE);								  	      break;
	    break;									  	  default:
    }											  	      print_usage("Error: Undefined Program Option: %s", (*curr)->lexeme);
}											  	      exit(EXIT_FAILURE);
											  	      return NULL;
void argparse_type (argtok_s **curr, files_s *parent)					      }
{											  }
    const char **assign;								  
											  const char **argparse_word (argtok_s **curr, files_s *parent)
    switch ((*curr)->id) {								  {
	case ARG_CHAR:									      if (strlen((*curr)->lexeme) == 1)
	    assign = argparse_char(curr, parent);					  	  return argparse_char (curr, parent);
	    break;									      if (!strcasecmp("regex", (*curr)->lexeme))
	case ARG_DASH:									  	  return &parent->regex;
	    *curr = (*curr)->next;							      if (!strcasecmp("cfg", (*curr)->lexeme))
	    assign = argparse_word(curr, parent);					  	  return &parent->cfg;







2014-02-11 02:00                                                                            main.c                                                                            Page 4


    if (!strcasecmp("source", (*curr)->lexeme))						  
	return &parent->source;								  void print_usage (const char *message, const char *curr)
    if (!strcasecmp("help", (*curr)->lexeme)) {						  {
	print_usage(NULL, NULL);							      if(message) {
	exit(EXIT_SUCCESS);								  	  if (curr)
	return NULL;									  	      printf(message, curr);
    }											  	  else
    print_usage("Error: Undefined Program Option: %s", (*curr)->lexeme);		  	      puts(message);
    exit(EXIT_FAILURE);									      }
    return NULL;									      printf("\n"COMP_HELP, "--help:", "-r | --regex:", "-p | --cfg:", "-s | --source:");
}											  }




















































2014-02-09 16:41                                                                            lex.h                                                                             Page 1


/*											      LEXTYPE_ERROR,
 lex.h											      LEXTYPE_TERM,
 Author: Jonathan Hamm									      LEXTYPE_EOL,
											      LEXTYPE_UNION,
 Description:										      LEXTYPE_KLEENE,
    Library for a lexical analyzer generator. This reads in a regular			      LEXTYPE_POSITIVE,
    expression and source file specified by the user. It then tokenizes the source	      LEXTYPE_ORNULL,
    file in conformance to the specified regular expression.				      LEXTYPE_RANDCHAR,
*/											      LEXTYPE_EPSILON,
											      LEXTYPE_PRODSYM,
#ifndef LEX_H_										      LEXTYPE_NONTERM,
#define LEX_H_										      LEXTYPE_OPENPAREN,
											      LEXTYPE_CLOSEPAREN,
#define INTEGER_WIDTH 4									      LEXTYPE_EOF,
#define REAL_WIDTH 8									      LEXTYPE_NULLSET,
											      LEXTYPE_START,
#include "general.h"									      LEXTYPE_CROSS,
											      LEXTYPE_CODE,
enum lex_attr_ {									      LEXTYPE_DOT,
    LEXATTR_NUM,									      LEXTYPE_OPENBRACKET,
    LEXATTR_WORD,									      LEXTYPE_CLOSEBRACKET,
    LEXATTR_EQU,									      LEXTYPE_NEGATE,
    LEXATTR_COMMA,									      /*
    LEXATTR_FAKEEOF									       Add lexical types here, then increment the
};											       value of the macro MACHID_START in semantics.c
											       */
enum lex_attr_num {									      LEXTYPE_ANNOTATE
    LEXATTR_INT,									  };
    LEXATTR_REAL,									  
    LEXATTR_LREAL									  #define LEXID_START	      LEXTYPE_ANNOTATE
};											  
											  #define MAX_LEXLEN 31
enum lex_attr_relop {									  
    LEXATTR_EQ,										  #define LEXATTR_DEFAULT     0
    LEXATTR_NEQ,									  #define LEXATTR_WSPACEEOL   1
    LEXATTR_LE,										  #define LEXATTR_ERRTOOLONG  0
    LEXATTR_LEQ,									  #define LEXATTR_EOLNEWPROD  1
    LEXATTR_GEQ,									  #define LEXATTR_CHARDIG     0
    LEXATTR_GE										  #define LEXATTR_NCHARDIG    1
};											  #define LEXATTR_BEGINDIG    2
											  
enum lex_attr_addop {									  #define CLOSTYPE_NONE	      0
    LEXATTR_PLUS,									  #define CLOSTYPE_KLEENE     1
    LEXATTR_MINUS,									  #define CLOSTYPE_POS	      2
    LEXATTR_OR										  #define CLOSTYPE_ORNULL     3
};											  
											  #define IDT_MANUAL	      0
enum lex_attr_mulop {									  #define IDT_AUTOINC_TYPE    1
    LEXATTR_MULT,									  #define IDT_AUTOINC_ATT     2
    LEXATTR_DIV1,									  
    LEXATTR_DIV2,									  typedef struct lex_s lex_s;
    LEXATTR_MOD,									  typedef struct tdat_s tdat_s;
    LEXATTR_AND										  typedef struct annotation_s annotation_s;
};											  typedef struct tlookup_s tlookup_s;
											  typedef struct idtable_s idtable_s;
enum lex_types_ {									  typedef struct idtnode_s idtnode_s;







2014-02-09 16:41                                                                            lex.h                                                                             Page 2


typedef struct toktype_s toktype_s;							  };
typedef struct token_s token_s;								  
typedef struct nfa_s nfa_s;								  struct idtnode_s
typedef struct nfa_node_s nfa_node_s;							  {
typedef struct nfa_edge_s nfa_edge_s;							      bool isterm;
typedef struct mach_s mach_s;								      char c;
typedef struct lextok_s lextok_s;							      tdat_s tdat;
typedef struct iditer_s iditer_s;							      uint8_t nchildren;
typedef struct regex_match_s regex_match_s;						      idtnode_s **children;
typedef struct scope_entry_s scope_entry_s;						  };
typedef struct scope_s scope_s;								  
typedef struct check_id_s check_id_s;							  struct idtable_s
											  {
typedef unsigned (*annotation_f) (token_s **, char *, unsigned *, void *);		      idtnode_s *root;
											  };
struct toktype_s									  
{											  struct nfa_s
    unsigned short val;									  {
    unsigned short attribute;								      nfa_node_s *start;
};											      nfa_node_s *final;
											  };
struct token_s										  
{											  struct nfa_node_s
    toktype_s type;									  {
    char *stype;									      uint16_t nedges;
    unsigned lineno;									      nfa_edge_s **edges;
    char lexeme[MAX_LEXLEN + 1];							  };
    char *lexeme_;									  
    token_s *prev;									  struct nfa_edge_s
    token_s *next;									  {
};											      bool negate;
											      annotation_s annotation;
struct tdat_s										      token_s *token;
{											      nfa_node_s *state;
    bool is_string;									  };
    union {										  
	char *stype;									  
	int itype;									  struct mach_s
    };											  {
    int att;										      bool    unlimited;
    sem_type_s type;									      bool    attr_id;
};											      bool    composite;
											      bool    typecount;
struct annotation_s									      long    lexlen;
{											      token_s *nterm;
    int attribute;									      nfa_s   *nfa;
    int length;										      nfa_s   *follow;
    bool attcount;									      mach_s *next;
    char *type;										  };
};											  
											  struct lex_s
struct tlookup_s									  {
{											      int typestart;
    bool is_found;									      uint16_t nmachs;
    tdat_s tdat;									      mach_s *machs;
    idtnode_s *node;									      idtable_s *kwtable;







2014-02-09 16:41                                                                            lex.h                                                                             Page 3


    idtable_s *idtable;									  };
    hash_s *tok_hash;									  
    llist_s *patch;									  struct check_id_s
    linetable_s *listing;								  {
};											      bool isfound;
											      int address;
struct lextok_s										      int width;
{											      scope_s *scope;
    lex_s *lex;										      sem_type_s *type;
    uint32_t lines;									  };
    token_s *tokens;									  
};											  extern scope_s *scope_root;
											  extern scope_s *scope_tree;
struct regex_match_s									  
{											  extern lextok_s lexf (lex_s *lex, char *buf, uint32_t linestart, bool listing);
    bool matched;									  extern lex_s *buildlex (const char *file);
    unsigned attribute;									  extern token_s *lexspec (const char *file, annotation_f af, void *data, bool lexmode);
};											  extern idtable_s *idtable_s_ (void);
											  extern int ntstrcmp (char *nterm, char *str);
struct scope_entry_s									  extern int quote_strcmp(char *quoted, char *str);
{											  extern void addstate (mach_s *mach, token_s *tok);
    int width;										  extern void addmachine (lex_s *lex, token_s *tok);
    char *entry;									  extern void *idtable_insert(idtable_s *table, char *str, tdat_s tdat);
    int address;									  extern void idtable_set(idtable_s *table, char *str, tdat_s tdat);
    sem_type_s type;									  extern tlookup_s idtable_lookup (idtable_s *table, char *str);
};											  extern int addtok (token_s **tlist, char *lexeme, uint32_t lineno, uint16_t type, uint16_
											  extern inline bool hashname(lex_s *lex, unsigned long token_val, char *name);
struct scope_s										  extern inline char *getname(lex_s *lex, unsigned long token_val);
{											  extern void settype(lex_s *lex, char *id, sem_type_s type);
    scope_entry_s *entries;								  extern sem_type_s gettype(lex_s *lex, char *id);
    struct {										  extern toktype_s gettoktype (lex_s *lex, char *id);
	sem_type_s type;								  extern regex_match_s lex_matches(lex_s *lex, char *machid, char *str);
	scope_s *child;									  
    } *children;									  extern void push_scope(char *id);
    char *id;										  extern void pop_scope(void);
    char *full_id;									  extern check_id_s check_id(char *id);
    int last_local_addr;								  extern bool check_redeclared(char *id);
    int last_arg_addr;									  extern void add_id(char *id, sem_type_s type, bool islocal);
    unsigned nentries;									  extern void print_scope(void *stream);
    unsigned nchildren;									  
    linetable_s *code;									  #endif
    scope_s *parent;





















2014-02-11 02:00                                                                            lex.c                                                                             Page 1


/*											  typedef struct match_s match_s;
 lex.c											  typedef struct regex_ann_s regex_ann_s;
 Author: Jonathan Hamm									  typedef struct prxa_expression_s prxa_expression_s;
											  
 Description:										  typedef void (*ann_callback_f) (token_s **, void *);
    Implementation for a lexical analyzer generator. This reads in a regular		  typedef void (*regex_callback_f) (token_s **, void *);
    expression and source file specified by the user. It then tokenizes the source	  
    file in conformance to the specified regular expression.				  struct exp__s
 */											  {
											      int8_t op;
#include "lex.h"									      nfa_s *nfa;
#include <string.h>									  };
#include <stdlib.h>									  
#include <stdio.h>									  struct lexargs_s
#include <ctype.h>									  {
#include <math.h>									      lex_s *lex;
											      mach_s *machine;
enum basic_ops_ {									      char *buf;
    OP_NOP = 0,										      uint16_t bread;
    OP_CONCAT,										      bool accepted;
    OP_UNION,										  };
    OP_GETID,										  
    OP_GETIDATT,									  struct pnonterm_s
    OP_NUM										  {
};											      bool success;
											      uint32_t offset;
//#define SHOW_PARAMETER_ADDRESSES							  };
											  
#define STACK_DIRECTION_UP 1								  struct overflow_s
#define STACK_DIRECTION_DOWN -1								  {
#define STACK_DIRECTION STACK_DIRECTION_DOWN						      size_t len;
											      char *str;
											  };
#define LERR_PREFIX	    "	   --Lexical Error: at line: %d: "			  
#define LERR_UNKNOWNSYM	    LERR_PREFIX "Unknown Character: %s"				  struct match_s
#define LERR_TOOLONG	    LERR_PREFIX "Token too long: %s"				  {
#define LERR_SPECTOOLONG    LERR_PREFIX "%s too long: %s"				      size_t n;
											      int attribute;
#define ISANNOTATE(curr)    ((*curr)->type.val == LEXTYPE_ANNOTATE)			      char *stype;
											      bool success;
#define MAX_IDLEN 		10							      overflow_s overflow;
#define MAX_INTLEN		10							  };
#define MAX_REALINT	5								  
#define MAX_REALFRACT	5								  struct regex_ann_s
#define MAX_REALEXP	2								  {
											      int *count;
#define ANNOTYPE	1								      mach_s *mach;
#define EDGETYPE	2								      llist_s *matchlist;
											  };
#define INT_CHAR_WIDTH	    10								  
											  struct prxa_expression_s
typedef struct exp__s exp__s;								  {
typedef struct nodelist_s nodelist_s;							      bool isint;
typedef struct lexargs_s lexargs_s;							      int ival;
typedef struct pnonterm_s pnonterm_s;							      char *strval;
typedef struct overflow_s overflow_s;							  };







2014-02-11 02:00                                                                            lex.c                                                                             Page 2


											  lex_s *buildlex(const char *file)
scope_s *scope_tree;									  {
unsigned scope_indent;									      token_s *list;
scope_s *scope_root;									      lex_s *lex;
											  
static void printlist(token_s *list);							      lex = lex_s_();
static void parray_insert(idtnode_s *tnode, uint8_t index, idtnode_s *child);		      list = lexspec(file, regex_annotate, NULL, true);
static uint16_t bsearch_tr(idtnode_s *tnode, char key);					      lex->typestart = parseregex(lex, &list);
static idtnode_s *trie_insert(idtable_s *table, idtnode_s *trie, char *str, tdat_s tdat);     return lex;
static tlookup_s trie_lookup(idtnode_s *trie, char *str);				  }
static unsigned regex_annotate(token_s **tlist, char *buf, unsigned *lineno, void *data); 
											  token_s *lexspec(const char *file, annotation_f af, void *data, bool lexmode)
static lex_s *lex_s_(void);								  {
static idtnode_s *patch_search(llist_s *patch, char *lexeme);				      unsigned i, j, lineno, tmp, bpos;
static int parseregex(lex_s *lex, token_s **curr);					      char *buf;
static void prx_keywords(lex_s *lex, token_s **curr, int *count);			      char lbuf[2*MAX_LEXLEN + 1];
static void prx_tokens(lex_s *lex, token_s **curr, int *count);				      token_s *list = NULL, *backup,
static void prx_tokens_(lex_s *lex, token_s **curr, int *count);			  	      *p, *pp;
static regex_ann_s *prx_texp(lex_s *lex, token_s **curr, int *count);			      extern uint32_t cfg_annotate (token_s **tlist, char *buf, uint32_t *lineno, void *dat
static nfa_s *prx_expression(lex_s *lex, token_s **curr, nfa_s **unfa, nfa_s **concat);	  
static exp__s prx_expression_(lex_s *lex, token_s **curr, nfa_s **unfa, nfa_s **concat);      buf = readfile(file);
static nfa_s *prx_term(lex_s *lex, token_s **curr, nfa_s **unfa, nfa_s **concat);	      if (!buf)
static nfa_s *prx_cclass(lex_s *lex, token_s **curr);					  	  return NULL;
static int prx_closure(lex_s *lex, token_s **curr);					      for (i = 0, j = 0, lineno = 1, bpos = 0; buf[i] != EOF; i++) {
											  	  switch (buf[i]) {
static void prxa_annotation(token_s **curr, void *ptr, regex_callback_f callback);	  	      case '|':
static void prxa_regexdef(token_s **curr, regex_ann_s *reg);				  		  addtok(&list, "|", lineno, LEXTYPE_UNION, LEXATTR_DEFAULT, NULL);
static void setann_val(int *location, int value);					  		  break;
static void prxa_edgestart(token_s **curr, nfa_edge_s *edge);				  	      case '(':
static void prxa_assigment(token_s **curr, nfa_edge_s *edge);				  		  if(lexmode)
static prxa_expression_s prxa_expression(token_s **curr, nfa_edge_s *edge);		  		      addtok(&list, "(", lineno, LEXTYPE_OPENPAREN, LEXATTR_DEFAULT, NULL);
static void prxa_expression_(token_s **curr, nfa_edge_s *edge);				  		  else
											  		      addtok(&list, "(", lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL);
static void regexdef_callback(token_s **curr, mach_s *mach);				  		  break;
static void nfaedge_callback(token_s **curr, nfa_edge_s *edge);				  	      case ')':
static int prx_annotation(nfa_edge_s *edge, token_s **curr, void *ptr, ann_callback_f cal 		  if(lexmode)
static int prxann_expressionlist(nfa_edge_s *edge, token_s **curr, void *ptr, ann_callbac 		      addtok(&list, ")", lineno, LEXTYPE_CLOSEPAREN, LEXATTR_DEFAULT, NULL)
static int prxann_expression(nfa_edge_s *edge, token_s **curr, void *ptr, ann_callback_f  		  else
static int prxann_expression_(nfa_edge_s *edge, token_s **curr, void *ptr, ann_callback_f 		      addtok(&list, ")", lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL);
static void prxann_equals(nfa_edge_s *edge, token_s **curr, void *ptr, ann_callback_f cal 		  break;
											  	      case '[':
static int prx_tokenid(lex_s *lex, token_s **curr);					  		  if(lexmode)
static void addcycle(nfa_node_s *start, nfa_node_s *dest);				  		      addtok(&list, "[", lineno, LEXTYPE_OPENBRACKET, LEXATTR_DEFAULT, NULL
static int tokmatch(char *buf, token_s *tok, unsigned *lineno, bool negate);		  		  else
match_s nfa_match(lex_s *lex, nfa_s *nfa, nfa_node_s *state, char *buf, unsigned *lineno) 		      addtok(&list, "[", lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL);
static char *make_lexerr(const char *errstr, int lineno, char *lexeme);			  		  break;
static void mscan(lexargs_s *args);							  	      case ']':
static mach_s *getmach(lex_s *lex, char *id);						  		  if(lexmode)
											  		      addtok(&list, "]", lineno, LEXTYPE_CLOSEBRACKET, LEXATTR_DEFAULT, NUL
static int addtok_(token_s **tlist, char *lexeme, uint32_t lineno, uint16_t type, uint16_ 		  else
											  		      addtok(&list, "]", lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL);
static void print_indent(FILE *f);							  		  break;
static void print_scope_(scope_s *root, FILE *f);					  	      case '^':
static int entry_cmp(const void *a, const void *b);					  		  if(lexmode)
static void print_frame(FILE *f, scope_s *s);						  		      addtok(&list, "^", lineno, LEXTYPE_NEGATE, LEXATTR_DEFAULT, NULL);
											  		  else







2014-02-11 02:00                                                                            lex.c                                                                             Page 3


		    addtok(&list, "^", lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL);	  		      else {
		break;									  			  p = calloc(1, sizeof(*p));
	    case '*':									  			  if (!p) {
		if(lexmode)								  			      perror("Memory Allocation Error");
		    addtok(&list, "*", lineno, LEXTYPE_KLEENE, LEXATTR_DEFAULT, NULL);	  			      exit(EXIT_FAILURE);
		else									  			  }
		    addtok(&list, "*", lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL);	  			  strcmp(p->lexeme, "EOL");
		break;									  			  p->next = pp;
	    case '+':									  			  p->type.val = LEXTYPE_EOL;
		if(lexmode)								  			  p->type.attribute = LEXATTR_EOLNEWPROD;
		    addtok(&list, "+", lineno, LEXTYPE_POSITIVE, LEXATTR_DEFAULT, NULL);  			  pp->prev = p;
		else									  		      }
		    addtok(&list, "+", lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL);	  		      i++;
		break;									  		  }
	    case '?':									  		  else
		if(lexmode)								  		      goto default_;
		    addtok(&list, "?", lineno, LEXTYPE_ORNULL, LEXATTR_DEFAULT, NULL);	  		      /* jump to default */
		else									  		  break;
		    addtok(&list, "?", lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL);	  	      case '<':
		break;									  		  lbuf[0] = '<';
	    case '\n':									  		  for (bpos = 1, i++, j = i; isalnum(buf[i]) || buf[i] == '_' || buf[i] ==
		lineno++;								  		  {
		addtok (&list, "EOL", lineno, LEXTYPE_EOL, LEXATTR_DEFAULT, NULL);	  		      if (bpos == MAX_LEXLEN) {
		break;									  			  addtok (&list, lbuf, lineno, LEXTYPE_ERROR, LEXATTR_ERRTOOLONG, N
	    case (char)0xCE:								  			  goto doublebreak_;
		if (buf[i+1] == (char)0xB5)						  		      }
		    addtok(&list, "EPSILON", lineno, LEXTYPE_EPSILON, LEXATTR_DEFAULT, NU 		      lbuf[bpos] = buf[i];
		i++;									  		  }
		break;									  		  if (i == j) {
	    case (char)0xE2:								  		      i--;
		if (buf[i+1] == (char)0xA8) {						  		      goto default_;
		    if (buf[i+2] == (char)0xAF) {					  		  }
			strcpy(lbuf, "\xE2\xA8\xAF");					  		  else if (buf[i] == '>' && bpos != MAX_LEXLEN) {
			addtok(&list, lbuf, lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL); 		      lbuf[bpos] = '>';
			i += 2;								  		      lbuf[bpos + 1] = '\0';
		    }									  		      addtok (&list, lbuf, lineno, LEXTYPE_NONTERM, LEXATTR_DEFAULT, NULL);
		}									  		  }
		break;									  		  else {
	    case '{':									  		      lbuf[bpos] = '\0';
		tmp = af(&list, &buf[i], &lineno, data);				  		      addtok (&list, &lbuf[0], lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL)
		if (tmp)								  		      i--;
		    i += tmp;								  		  }
		else {									  		  break;
		    perror("Error Parsing Regex");					  	      case '.':
		    exit(EXIT_FAILURE);							  		  if(lexmode)
		}									  		      addtok(&list, ". (metachar)", lineno, LEXTYPE_DOT, LEXATTR_DEFAULT, N
		break;									  		  else
	    case '-':									  		      addtok(&list, ".", lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL);
		if (buf[i+1] == '>') {							  		  break;
		    addtok (&list, "->", lineno, LEXTYPE_PRODSYM, LEXATTR_DEFAULT, NULL); 	      case '\\':
		    for (p = list->prev; p && p->type.val != LEXTYPE_EOL; p = p->prev) {  		  lbuf[0] = buf[++i];
			if (!p->prev)							  		  lbuf[1] = '\0';
			    pp = p;							  		  addtok(&list, lbuf, lineno, LEXTYPE_TERM, LEXATTR_DEFAULT, NULL);
		    }									  		  break;
		    if (p)								  default_:
			p->type.attribute = LEXATTR_EOLNEWPROD;				  	      default:







2014-02-11 02:00                                                                            lex.c                                                                             Page 4


		if (isspace(buf[i]))							  		  break;
		    break;								  	  }
		for (bpos = 0, j = LEXATTR_CHARDIG; !isspace(buf[i]) && buf[i] != EOF; bp doublebreak_:
		{									  	  ;
		    if (bpos == MAX_LEXLEN) {						      }
			lbuf[bpos] = '\0';						      addtok(&list, "$", lineno, LEXTYPE_EOF, LEXATTR_DEFAULT, NULL);
			addtok (&list, lbuf, lineno, LEXTYPE_ERROR, LEXATTR_ERRTOOLONG, N     while (list->prev) {
			break;								  	  if (list->type.val == LEXTYPE_EOL && list->type.attribute == LEXATTR_DEFAULT) {
		    }									  	      backup = list;
		    switch(buf[i]) {							  	      list->prev->next = list->next;
			case '-':							  	      if (list->next)
			    if (buf[i+1] != '>')					  		  list->next->prev = list->prev;
				break;							  	      list = list->prev;
			    goto dot_;							  	      free(backup);
			case '<':							  	  }
			    if (!(isalnum(buf[i+1]) || buf[i+1] == '_' || buf[i+1] == '\' 	  else
				break;							  	      list = list->prev;
dot_:											      }
			case '.':							      if (list->type.val == LEXTYPE_EOL && list->type.attribute == LEXATTR_DEFAULT) {
			case '(':							  	  backup = list;
			case ')':							  	  list = list->next;
			case '*':							  	  if (list)
			case '+':							  	      list->prev = NULL;
			case '?':							  	  free(backup);
			case '|':							      }
			case '{':							      return list;
			case '[':							  }
			case ']':							  
			case '\\':							  unsigned regex_annotate(token_s **tlist, char *buf, unsigned *lineno, void *data)
			case '/':							  {
			    if (bpos > 0) {						      unsigned i = 0, bpos = 0;
				lbuf[bpos] = '\0';					      char tmpbuf[MAX_LEXLEN+1];
				addtok (&list, lbuf, lineno, LEXTYPE_TERM, j, NULL);	  
			    }								      buf++;
			    i--;							      while (buf[i] != '}') {
			    goto doublebreak_;						  	  while (isspace(buf[i])) {
		    }									  	      if (buf[i] == '\n')
		    if (buf[i] == '\\')							  		  ++*lineno;
			i++;								  	      i++;
		    lbuf[bpos] = buf[i];						  	  }
		    if (!isalnum(buf[i]))						  	  if (buf[i] == '}')
			j = LEXATTR_NCHARDIG;						  	      continue;
		}									  	  bpos = 0;
		if (!bpos) {								  	  if (isalpha(buf[i]) || buf[i] == '<') {
		    lbuf[0] = buf[i];							  	      tmpbuf[bpos] = buf[i];
		    lbuf[1] = '\0';							  	      for (bpos++, i++; isalpha(buf[i]) || isdigit(buf[i]) || buf[i] == '>'; bpos++
		    addtok (&list, lbuf, lineno, LEXTYPE_TERM, j, NULL);		  		  if (bpos == MAX_LEXLEN)
		}									  		      return false;
		else {									  		  tmpbuf[bpos] = buf[i];
		    lbuf[bpos] = '\0';							  		  if (buf[i] == '>') {
		    if (isdigit(buf[i]))						  		      bpos++;
			addtok (&list, lbuf, lineno, LEXTYPE_TERM, j, NULL);		  		      i++;
		    else								  		      break;
			addtok (&list, lbuf, lineno, LEXTYPE_TERM, LEXATTR_BEGINDIG, NULL 		  }
		    i--;								  	      }
		}									  	      tmpbuf[bpos] = '\0';







2014-02-11 02:00                                                                            lex.c                                                                             Page 5


	    addtok(tlist, tmpbuf, *lineno, LEXTYPE_ANNOTATE, LEXATTR_WORD, NULL);	  	  printf("%s\n", list->lexeme);
	}										  	  list = list->next;
	else if (isdigit(buf[i])) {							      }
	    tmpbuf[bpos] = buf[i];							  }
	    for (bpos++, i++; isdigit(buf[i]); bpos++, i++) {				  
		if (bpos == MAX_LEXLEN)							  int parseregex(lex_s *lex, token_s **list)
		    return false;							  {
		tmpbuf[bpos] = buf[i];							      int types = LEXID_START;
	    }										  
	    tmpbuf[bpos] = '\0';							      prx_keywords(lex, list, &types);
	    addtok(tlist, tmpbuf, *lineno, LEXTYPE_ANNOTATE, LEXATTR_NUM, NULL);	      if ((*list)->type.val != LEXTYPE_EOL) {
	}										  	  fprintf(stderr, "Syntax Error at line %u: Expected EOL but got %s\n", (*list)->li
	else if (buf[i] == '=') {							  	  assert(false);
	    i++;									      }
	    addtok(tlist, "=", *lineno, LEXTYPE_ANNOTATE, LEXATTR_EQU, NULL);		  
	}										      *list = (*list)->next;
	else if (buf[i] == ',') {							      prx_tokens(lex, list, &types);
	    i++;									      if ((*list)->type.val != LEXTYPE_EOF) {
	    addtok(tlist, ",", *lineno, LEXTYPE_ANNOTATE, LEXATTR_COMMA, NULL);		  	  fprintf(stderr, "Syntax Error at line %u: Expected $ but got %s\n", (*list)->line
	}										  	  assert(false);
	else {										      }
	    fprintf(stderr, "Illegal character sequence in annotation at line %u: %c\n",      lex->idtable = idtable_s_();
	    exit(EXIT_FAILURE);								      return types;
	}										  }
    }											  
    addtok(tlist, "$", *lineno, LEXTYPE_ANNOTATE, LEXATTR_FAKEEOF, NULL);		  void prx_keywords(lex_s *lex, token_s **curr, int *counter)
    return i+1;										  {
}											      char *lexeme;
											      idtnode_s *node;
int addtok(token_s **tlist, char *lexeme, uint32_t lineno, uint16_t type, uint16_t attrib     sem_type_s init_type;
{											  
    token_s *ntok;									      init_type.type = ATTYPE_NULL;
											      while ((*curr)->type.val == LEXTYPE_TERM) {
    ntok = calloc(1, sizeof(*ntok));							  	  node = NULL;
    if (!ntok) {									  	  lexeme = (*curr)->lexeme;
	perror("Memory Allocation Error");						  	  ++*counter;
	return -1;									  	  idtable_insert(lex->kwtable, lexeme, (tdat_s){.is_string = false, .itype = *count
    }											  	  *curr = (*curr)->next;
    ntok->type.val = type;								      }
    ntok->type.attribute = attribute;							      ++*counter;
    ntok->lineno = lineno;								  }
    ntok->stype = stype;								  
    strcpy(ntok->lexeme, lexeme);							  void prx_tokens(lex_s *lex, token_s **curr, int *count)
    if (!*tlist)									  {
	*tlist = ntok;									      prx_texp(lex, curr, count);
    else {										      prx_tokens_(lex, curr, count);
	(*tlist)->next = ntok;								  }
	ntok->prev = *tlist;								  
	*tlist = ntok;									  void prx_tokens_(lex_s *lex, token_s **curr, int *count)
    }											  {
    return 0;										      regex_ann_s *reg;
}											      mach_s *mach;
											      llist_s *matches = NULL, *mcurr, *miter;
void printlist(token_s *list)								  
{											      if ((*curr)->type.val == LEXTYPE_EOL) {
    while (list) {									  	  *curr = (*curr)->next;







2014-02-11 02:00                                                                            lex.c                                                                             Page 6


	reg = prx_texp (lex, curr, count);						  	  exit(EXIT_FAILURE);
	if (reg)									      }
	    llpush(&matches, reg);							      edge->token = token;
	prx_tokens_(lex, curr, count);							      edge->state = state;
    }											      edge->annotation.attcount = false;
    while (matches) {									      edge->annotation.attribute = -1;
	mcurr = llpop(&matches);							      edge->annotation.length = -1;
	reg = mcurr->ptr;								      return edge;
	for (miter = reg->matchlist; miter; miter = miter->next) {			  }
	    for (mach = lex->machs; mach; mach = mach->next) {				  
		if (!ntstrcmp(mach->nterm->lexeme, miter->ptr))				  void addedge(nfa_node_s *start, nfa_edge_s *edge)
		    break;								  {
	    }										      if (start->nedges)
	    if (!mach) {								  	  start->edges = realloc(start->edges, sizeof(*start->edges) * (start->nedges+1));
		fprintf(stderr, "Error: regex %s not found.\n", miter->ptr);		      else
		exit(EXIT_FAILURE);							  	  start->edges = malloc(sizeof(*start->edges));
	    }										      if (!start->edges) {
	    mach->nterm->type = reg->mach->nterm->type;					  	  perror("Memory Allocation error");
	}										  	  exit(EXIT_FAILURE);
	free_llist(reg->matchlist);							      }
	free(mcurr);									      start->edges[start->nedges] = edge;
    }											      start->nedges++;
}											  }
											  
static inline nfa_s *nfa_(void)								  void reparent(nfa_node_s *parent, nfa_node_s *oldparent)
{											  {
    return calloc(1, sizeof(nfa_s));							      uint16_t i;
}											  
											      for (i = 0; i < oldparent->nedges; i++)
static inline nfa_node_s *nfa_node_s_(void)						  	  addedge (parent, oldparent->edges[i]);
{											  }
    return calloc(1, sizeof(nfa_node_s));						  
}											  void insert_at_branch(nfa_s *unfa, nfa_s *concat, nfa_s *insert)
											  {
token_s *make_epsilon(void)								      int i;
{											  
    token_s *new;									      for (i = unfa->start->nedges-1; i >= 0; i--) {
											  	  if (unfa->start->edges[i]->state == concat->start) {
    new = calloc(1, sizeof(*new));							  	      reparent (insert->final, concat->start);
    if (!new) {										  	      insert->final = concat->final;
	perror("Memory Allocation Error");						  	      unfa->start->edges[i]->state = insert->start;
	exit(EXIT_FAILURE);								  	      free(concat);
    }											  	      return;
    strcpy(new->lexeme, "EPSILON");							  	  }
    new->type.val = LEXTYPE_EPSILON;							      }
    new->type.attribute = LEXATTR_DEFAULT;						  }
    return new;										  
}											  regex_ann_s *prx_texp(lex_s *lex, token_s **curr, int *count)
											  {
nfa_edge_s *nfa_edge_s_(token_s *token, nfa_node_s *state)				      idtnode_s *tnode = NULL;
{											      nfa_s *uparent = NULL, *concat = NULL;
    nfa_edge_s *edge;									      regex_ann_s *reg;
											  
    edge = calloc(1, sizeof(*edge));							      if ((*curr)->type.val == LEXTYPE_NONTERM) {
    if (!edge) {									  	  addmachine(lex, *curr);
	perror("Memory Allocation error");						  	  *curr = (*curr)->next;







2014-02-11 02:00                                                                            lex.c                                                                             Page 7


	++*count;									  	      addedge(clos_nfa->final, nfa_edge_s_(make_epsilon(), term->start));
	lex->machs->nterm->type.val = *count;						  	      term = clos_nfa;
	reg = malloc(sizeof(*reg));							  	      break;
	if (!reg) {									  	  case CLOSTYPE_ORNULL:
	    perror("Memory Allocation Error");						  	      addedge(term->start, nfa_edge_s_(make_epsilon(), term->final));
	    exit(EXIT_FAILURE);								  	      break;
	}										  	  case CLOSTYPE_NONE:
	reg->count = count;								  	      break;
	reg->mach = lex->machs;								  	  default:
	reg->matchlist = NULL;								  	      break;
	prxa_annotation(curr, reg, (void (*)(token_s **, void *))prxa_regexdef);	      }
	if (!reg->matchlist) {								      exp_ = prx_expression_(lex, curr, unfa, concat);
	    free(reg);									      if (exp_.op == OP_UNION) {
	    reg = NULL;									  	  if (*unfa) {
	}										  	      addedge((*unfa)->start, nfa_edge_s_(make_epsilon(), term->start));
	tnode = patch_search(lex->patch, lex->machs->nterm->lexeme);			  	      addedge(term->final, nfa_edge_s_(make_epsilon(), (*unfa)->final));
	if ((*curr)->type.val == LEXTYPE_PRODSYM) {					  	  }
	    *curr = (*curr)->next;							  	  else {
	    lex->machs->nfa = prx_expression(lex, curr, &uparent, &concat);		  	      un_nfa = nfa_();
	    if (uparent)								  	      un_nfa->start = nfa_node_s_();
		lex->machs->nfa = uparent;						  	      un_nfa->final = nfa_node_s_();
	}										  	      addedge(un_nfa->start, nfa_edge_s_(make_epsilon(), term->start));
	else {										  	      addedge(un_nfa->start, nfa_edge_s_(make_epsilon(), exp_.nfa->start));
	    fprintf(stderr, "Syntax Error at line %u: Expected '->' but got: %s\n", (*cur 	      addedge(term->final, nfa_edge_s_(make_epsilon(), un_nfa->final));
	    assert(false);								  	      addedge(exp_.nfa->final, nfa_edge_s_(make_epsilon(), un_nfa->final));
	}										  	      *unfa = un_nfa;
    }											  	  }
    else {										  	  *concat = term;
	fprintf(stderr, "Syntax Error at line %u: Expected nonterminal: <...>, but got: %     }
	assert(false);									      else if (exp_.op == OP_CONCAT) {
    }											  	  if (*unfa) {
    return reg;										  	      insert_at_branch (*unfa, *concat, term);
}											  	      *concat = term;
											  	  }
nfa_s *prx_expression(lex_s *lex, token_s **curr, nfa_s **unfa, nfa_s **concat)		  	  else {
{											  	      reparent(term->final, exp_.nfa->start);
    exp__s exp_;									  	      term->final = exp_.nfa->final;
    nfa_s *un_nfa, *clos_nfa, *term;							  	  }
											      }
    term = prx_term(lex, curr, unfa, concat);						      return term;
    switch (prx_closure(lex, curr)) {							  }
	case CLOSTYPE_KLEENE:								  
	    clos_nfa = nfa_();								  exp__s prx_expression_(lex_s *lex, token_s **curr, nfa_s **unfa, nfa_s **concat)
	    clos_nfa->start = nfa_node_s_();						  {
	    clos_nfa->final = nfa_node_s_();						      if ((*curr)->type.val == LEXTYPE_UNION) {
	    addedge(clos_nfa->start, nfa_edge_s_(make_epsilon(), term->start));		  	  *curr = (*curr)->next;
	    addedge(clos_nfa->start, nfa_edge_s_(make_epsilon(), clos_nfa->final));	  	  switch ((*curr)->type.val) {
	    addedge(term->final, nfa_edge_s_(make_epsilon(), clos_nfa->final));		  	      case LEXTYPE_OPENPAREN:
	    addedge(term->final, nfa_edge_s_(make_epsilon(), term->start));		  	      case LEXTYPE_DOT:
	    term = clos_nfa;								  	      case LEXTYPE_TERM:
	    break;									  	      case LEXTYPE_OPENBRACKET:
	case CLOSTYPE_POS:								  	      case LEXTYPE_NONTERM:
	    clos_nfa = nfa_();								  	      case LEXTYPE_EPSILON:
	    clos_nfa->start = term->start;						  		  return (exp__s){.op = OP_UNION, .nfa = prx_expression(lex, curr, unfa, co
	    clos_nfa->final = nfa_node_s_();						  	      default:
	    addedge(term->final, nfa_edge_s_(make_epsilon(), clos_nfa->final));		  		  *curr = (*curr)->next;







2014-02-11 02:00                                                                            lex.c                                                                             Page 8


		fprintf(stderr, "Syntax Error line %u: Expected '(' , terminal, or nonter 		      *curr = (*curr)->next;
		assert(false);								  		  else {
		/* make compiler happy */						  		      fprintf(stderr, "Synax Error: Expected ] but got %s\n", (*curr)->lexe
		return (exp__s){.op = -1, .nfa = NULL};					  		      assert(false);
	}										  		  }
    }											  	      }
    switch ((*curr)->type.val) {							  	      else {
	case LEXTYPE_OPENPAREN:								  		  nfa = nfa_();
	case LEXTYPE_DOT:								  		  nfa->start = nfa_node_s_();
	case LEXTYPE_TERM:								  		  nfa->final = nfa_node_s_();
	case LEXTYPE_OPENBRACKET:							  		  edge = nfa_edge_s_(*curr, nfa->final);
	case LEXTYPE_NONTERM:								  		  addedge(nfa->start, edge);
	case LEXTYPE_EPSILON:								  		  *curr = (*curr)->next;
	    return (exp__s){.op = OP_CONCAT, .nfa = prx_expression(lex, curr, unfa, conca 		  prxa_annotation(curr, edge, (void (*)(token_s **curr, void *))prxa_edgest
	    break;									  	      }
	default:									  	      exp_ = prx_expression_(lex, curr, unfa, concat);
	    return (exp__s){.op = OP_NOP, .nfa = NULL};					  	      if (exp_.op == OP_UNION) {
    }											  		  if (*unfa) {
}											  		      addedge((*unfa)->start, nfa_edge_s_(make_epsilon(), nfa->start));
											  		      addedge(nfa->final, nfa_edge_s_(make_epsilon(), (*unfa)->final));
nfa_s *prx_term(lex_s *lex, token_s **curr, nfa_s **unfa, nfa_s **concat)		  		  }
{											  		  else {
    bool isclass = false;								  		      u_nfa = nfa_();
    exp__s exp_;									  		      u_nfa->start = nfa_node_s_();
    nfa_edge_s *edge;									  		      u_nfa->final = nfa_node_s_();
    nfa_s *nfa, *unfa_ = NULL, *concat_ = NULL, *backup1, *u_nfa;			  		      addedge(u_nfa->start, nfa_edge_s_(make_epsilon(), nfa->start));
											  		      addedge(u_nfa->start, nfa_edge_s_(make_epsilon(), exp_.nfa->start));
    switch((*curr)->type.val) {								  		      addedge(nfa->final, nfa_edge_s_(make_epsilon(), u_nfa->final));
	case LEXTYPE_OPENPAREN:								  		      addedge(exp_.nfa->final, nfa_edge_s_(make_epsilon(), u_nfa->final));
	    *curr = (*curr)->next;							  		      *unfa = u_nfa;
	    backup1 = *unfa;								  		  }
	    nfa = prx_expression(lex, curr, &unfa_, &concat_);				  		  *concat = nfa;
	    if ((*curr)->type.val != LEXTYPE_CLOSEPAREN) {				  	      }
		fprintf(stderr, "Syntax Error at line %u: Expected ')' , but got: %s\n",  	      else if (exp_.op == OP_CONCAT) {
		assert(false);								  		  if (*unfa) {
	    }										  		      insert_at_branch (*unfa, *concat, nfa);
	    *curr = (*curr)->next;							  		      *concat = nfa;
	    *unfa = backup1;								  		  }
	    if (unfa_) {								  		  else {
		*concat = unfa_;							  		      reparent (nfa->final, exp_.nfa->start);
		return unfa_;								  		      nfa->final = exp_.nfa->final;
	    }										  		  }
	    else {									  	      }
		*concat = nfa;								  	      break;
		return nfa;								  	  default:
	    }										  	      fprintf(stderr, "Syntax Error at line %u: Expected '(' , terminal , or nonter
	case LEXTYPE_OPENBRACKET:							  	      assert(false);
	    isclass = true;								  	      break;
	case LEXTYPE_DOT:								      }
	case LEXTYPE_TERM:								      return nfa;
	case LEXTYPE_NONTERM:								  }
	case LEXTYPE_EPSILON:								  
	    if(isclass) {								  nfa_s *prx_cclass(lex_s *lex, token_s **curr)
		*curr = (*curr)->next;							  {
		nfa = prx_cclass (lex, curr);						      nfa_s *class;
		if((*curr)->type.val == LEXTYPE_CLOSEBRACKET)				      nfa_node_s *n1, *n2;







2014-02-11 02:00                                                                            lex.c                                                                             Page 9


    nfa_edge_s *edge, *e1, *e2;								  	  case CLOSTYPE_POS:
    bool negate = false;								  	  case CLOSTYPE_ORNULL:
											  	  default:
    class = nfa_();									  	      return type;
    class->start = nfa_node_s_();							      }
    class->final = nfa_node_s_();							  }
    if ((*curr)->type.val > LEXTYPE_ERROR && (*curr)->type.val <= LEXTYPE_ANNOTATE) {	  
	if((*curr)->type.val == LEXTYPE_NEGATE) {					  void prxa_annotation(token_s **curr, void *ptr, regex_callback_f callback)
	    negate = true;								  {
	    *curr = (*curr)->next;							      if ((*curr)->type.val == LEXTYPE_ANNOTATE) {
	}										  	  callback(curr, ptr);
	while ((*curr)->type.val != LEXTYPE_CLOSEBRACKET) {				  	  if (ISANNOTATE(curr) && (*curr)->type.attribute == LEXATTR_FAKEEOF)
	    if((*curr)->type.val == LEXTYPE_EOF) {					  	      *curr = (*curr)->next;
		fprintf(stderr, "Syntax Error at line %d: Expected ] but got %s\n", (*cur 	  else {
		assert(false);								  	      fprintf(stderr, "Syntax Error at line %d: Expected } but got %s\n", (*curr)->
	    }										  	      assert(false);
	    n1 = nfa_node_s_();								  	  }
	    n2 = nfa_node_s_();								      }
	    edge = nfa_edge_s_(*curr, n2);						  }
	    edge->negate = negate;							  
	    addedge(n1, edge);								  void prxa_regexdef(token_s **curr, regex_ann_s *reg)
	    e1 = nfa_edge_s_(make_epsilon(), class->final);				  {
	    addedge(n2, e1);								      mach_s *mach = reg->mach;
	    e2 = nfa_edge_s_(make_epsilon(), n1);					  
	    addedge(class->start, e2);							      while (ISANNOTATE(curr) && (*curr)->type.attribute != LEXATTR_FAKEEOF) {
	    *curr = (*curr)->next;							  	  if (!strcasecmp((*curr)->lexeme, "typecount"))
	}										  	      mach->typecount = true;
    }											  	  else if (!strcasecmp((*curr)->lexeme, "idtype")) {
    return class;									  	      mach->attr_id = true;
}											  	      mach->composite = false;
											  	  }
											  	  else if (!strcasecmp((*curr)->lexeme, "definition")) {
int prx_closure(lex_s *lex, token_s **curr)						  	      --*reg->count;
{											  	      mach->composite = true;
	int type;									  	      mach->attr_id = false;
											  	  }
    switch((*curr)->type.val) {								  	  else if (!strcasecmp((*curr)->lexeme, "length")) {
	case LEXTYPE_KLEENE:								  	      *curr = (*curr)->next;
	    *curr = (*curr)->next;							  	      if (ISANNOTATE(curr) && (*curr)->type.attribute == LEXATTR_EQU) {
	    type = CLOSTYPE_KLEENE;							  		  *curr = (*curr)->next;
	    break;									  		  if (ISANNOTATE(curr) && (*curr)->type.attribute == LEXATTR_NUM)
	case LEXTYPE_POSITIVE:								  		      mach->lexlen = safe_atol((*curr)->lexeme);
	    *curr = (*curr)->next;							  		  else if (ISANNOTATE(curr) && (*curr)->type.attribute == LEXATTR_WORD) {
	    type = CLOSTYPE_POS;							  		      if (!strcasecmp((*curr)->lexeme, "unlimited"))
	    break;									  			  mach->unlimited = true;
	case LEXTYPE_ORNULL:								  		      else {
	    *curr = (*curr)->next;							  			  fprintf(stderr, "Error at line %d: Unknown length specifier: %s\n
	    type = CLOSTYPE_ORNULL;							  			  assert(false);
	    break;									  		      }
	default:									  		  }
	    return CLOSTYPE_NONE;							  		  else {
    }											  		      fprintf(stderr, "Syntax Error at line %d: Expected number but got %s\
    switch (prx_closure (lex, curr)) {							  		      assert(false);
	case CLOSTYPE_NONE:								  		  }
	    return type;								  	      }
	case CLOSTYPE_KLEENE:								  	      else {







2014-02-11 02:00                                                                            lex.c                                                                            Page 10


		fprintf(stderr, "Syntax Error at line %d: Expected = but got %s\n", (*cur 	  if (edge->annotation.attribute != -1) {
		assert(false);								  	      fprintf(stderr, "Error at line %d at %s: Incompatible attribute type combinat
	    }										  	      exit(EXIT_FAILURE);
	}										  	  }
	else if (!strcasecmp((*curr)->lexeme, "type")) {				  	  edge->annotation.attcount = true;
	    *curr = (*curr)->next;							      }
	    if (ISANNOTATE(curr) && (*curr)->type.attribute == LEXATTR_EQU) {		      *curr = (*curr)->next;
		*curr = (*curr)->next;							      val = prxa_expression(curr, edge);
		if (ISANNOTATE(curr)) {							      if (!strcasecmp(str, "attribute")) {
		    switch((*curr)->type.attribute) {					  	  assert(val.isint);
			case LEXATTR_WORD:						  	  setann_val(&edge->annotation.attribute, val.ival);
			    llpush(&reg->matchlist, (*curr)->lexeme);			      }
			    break;							      else if (!strcasecmp(str, "length")) {
			case LEXATTR_NUM:						  	  assert(val.isint);
			    mach->nterm->type.val = safe_atol((*curr)->lexeme);		  	  setann_val(&edge->annotation.length, val.ival);
			    break;							      }
			default:							      else if (!strcasecmp(str, "type")) {
			    fprintf(stderr, "Error: Expected word or number but got %s\n" 	  assert(!val.isint);
			    assert(false);						  	  edge->annotation.type = val.strval;
			    break;							      }
		    }									      else {
		}									  	  fprintf(stderr, "Error at line %d: Unknown attribute type: %s\n", (*curr)->lineno
	    }										  	  assert(false);
	    else {									      }
		fprintf(stderr, "Syntax Error at line %d: Expected = but got %s\n", (*cur }
		assert(false);								  
	    }										  void setann_val(int *location, int value)
	}										  {
	else {										      if (*location == -1)
	    fprintf(stderr, "Error at line %d: Unknown regex definition mode %s\n", (*cur 	  *location = value;
	    assert(false);								      else {
	}										  	  puts("Error: Regex Attribute used more than once.\n");
	*curr = (*curr)->next;								  	  exit(EXIT_FAILURE);
	if (ISANNOTATE(curr) && (*curr)->type.attribute == LEXATTR_COMMA)		      }
	    *curr = (*curr)->next;							  }
    }											  
}											  void prxa_edgestart(token_s **curr, nfa_edge_s *edge)
											  {
void prxa_assignment(token_s **curr, nfa_edge_s *edge)					      if (ISANNOTATE(curr)) {
{											  	  switch ((*curr)->type.attribute) {
    prxa_expression_s val;								  	      case LEXATTR_WORD:
    char *str;										  		  prxa_assignment(curr, edge);
											  		  break;
    if (ISANNOTATE(curr)) {								  	      case LEXATTR_NUM:
											  		  if (edge->annotation.attribute != -1) {
	if ((*curr)->type.attribute == LEXATTR_FAKEEOF) {				  		      fprintf(stderr, "Error at line %d: Edge attribute value %s assigned m
	    return;									  		      exit(EXIT_FAILURE);
	}										  		  }
    }											  		  edge->annotation.attribute = safe_atol((*curr)->lexeme);
    else {										  		  *curr = (*curr)->next;
	fprintf(stderr, "Error at line %d: Unexpected %s\n", (*curr)->lineno, (*curr)->le 		  break;
	exit(EXIT_FAILURE);								  	  }
    }											      }
											      else {
    str = (*curr)->lexeme;								  	  fprintf(stderr, "Error parsing regex annotation at line %d: %s\n", (*curr)->linen
    if (!strcasecmp(str, "attcount")) {							  	  exit(EXIT_FAILURE);







2014-02-11 02:00                                                                            lex.c                                                                            Page 11


    }											      }
}											  }
											  
prxa_expression_s prxa_expression(token_s **curr, nfa_edge_s *edge)			  lex_s *lex_s_(void)
{											  {
    prxa_expression_s ret = {0};							      lex_s *lex;
											  
    if (ISANNOTATE(curr)) {								      lex = calloc(1,sizeof(*lex));
	switch ((*curr)->type.attribute) {						      if (!lex) {
	    case LEXATTR_EQU:								  	  perror("Memory Allocation Error");
		*curr = (*curr)->next;							  	  return NULL;
		if (ISANNOTATE(curr)) {							      }
		    if ((*curr)->type.attribute == LEXATTR_NUM) {			      lex->kwtable = idtable_s_();
			ret.isint = true;						      lex->tok_hash = hash_(basic_hashf, basic_isequalf);
			ret.ival = safe_atol((*curr)->lexeme);				      lex->listing = linetable_s_();
		    }									      return lex;
		    else if ((*curr)->type.attribute == LEXATTR_WORD) {			  }
			ret.isint = false;						  
			ret.strval = (*curr)->lexeme;					  idtnode_s *patch_search(llist_s *patch, char *lexeme)
		    }									  {
		    *curr = (*curr)->next;						      while (patch) {
		    prxa_expression_(curr, edge);					  	  if (((idtnode_s *)patch->ptr)->tdat.is_string) {
		}									  	      if (!strcmp(((idtnode_s *)patch->ptr)->tdat.stype, lexeme))
		else {									  		  return patch->ptr;
		    fprintf(stderr, "Error parsing regex annotation at line %d : %s\n", ( 	  }
		    exit(EXIT_FAILURE);							  	  patch = patch->next;
		}									      }
		break;									      return NULL;
	    case LEXATTR_FAKEEOF:							  }
		return (prxa_expression_s){.isint = true, .ival = -1, .strval = NULL};	  
	    default:									  idtable_s *idtable_s_(void)
		fprintf(stderr, "Syntax error at line %d: Expected = or } but got: %s\n", {
		assert(false);								      idtable_s *table;
	}										  
    }											      table = malloc(sizeof(*table));
    return ret;										      if (!table) {
}											  	  perror("Memory Allocation Error");
											  	  return NULL;
void prxa_expression_(token_s **curr, nfa_edge_s *edge)					      }
{											      table->root = calloc(1, sizeof(*table->root));
    if (ISANNOTATE(curr)) {								      if (!table->root) {
	switch ((*curr)->type.attribute) {						  	  perror("Memory Allocation Error");
	    case LEXATTR_COMMA:								  	  return NULL;
		*curr = (*curr)->next;							      }
		prxa_assignment(curr, edge);						      return table;
		break;									  }
	    case LEXATTR_FAKEEOF:							  
		break;									  void *idtable_insert(idtable_s *table, char *str, tdat_s tdat)
	    default:									  {
		fprintf(stderr, "Syntax error at line %d: Expected , or } but got: %s\n",     return trie_insert(table, table->root, str, tdat);
		assert(false);								  }
	}										  
    }											  void idtable_set(idtable_s *table, char *str, tdat_s tdat)
    else {										  {
	fprintf(stderr, "Error parsing regex annotation at line %d: %s\n", (*curr)->linen     tlookup_s lookup;
	assert(false);									  







2014-02-11 02:00                                                                            lex.c                                                                            Page 12


    lookup = idtable_lookup(table, str);						  
    lookup.node->tdat = tdat;								  tlookup_s trie_lookup(idtnode_s *trie, char *str)
}											  {
											      uint16_t search;
tlookup_s idtable_lookup(idtable_s *table, char *str)					  
{											      search = bsearch_tr(trie, *str);
    return trie_lookup(table->root, str);						      if (search & 0x8000)
}											  	  return (tlookup_s){.is_found = false, .tdat = trie->tdat};
											      if (!*str)
idtnode_s *trie_insert(idtable_s *table, idtnode_s *trie, char *str, tdat_s tdat)	  	  return (tlookup_s){.is_found = true, .tdat = trie->children[search]->tdat, .node
{											      return trie_lookup(trie->children[search], str+1);
    int search;										  }
    idtnode_s *nnode;									  
											  uint16_t bsearch_tr(idtnode_s *tnode, char key)
    if (!trie->nchildren)								  {
	search = 0;									  	int16_t mid, low, high;
    else {										  
	search = bsearch_tr(trie, *str);						      low = 0;
	if (search & 0x8000)								      high = tnode->nchildren-1;
	    search &= ~0x8000;								      for (mid = low+(high-low)/2; high >= low; mid = low+(high-low)/2) {
	else if (*str)									  	  if (key < tnode->children[mid]->c)
	    return trie_insert(table, trie->children[search], str+1, tdat);		  	      high = mid - 1;
	else										  	  else if (key > tnode->children[mid]->c)
	    return NULL;								  	      low = mid + 1;
    }											  	  else
    nnode = calloc(1, sizeof(*nnode));							  	      return mid;
    if (!nnode) {									      }
	perror("Memory Allocation Error");						      if (high < low)
	exit(EXIT_FAILURE);								  	  return mid | 0x8000;
    }											      return mid;
    nnode->c = *str;									  }
    if (!*str) {									  
	nnode->tdat = tdat;								  int ntstrcmp(char *nterm, char *str)
	parray_insert (trie, search, nnode);						  {
	return nnode;									      int i, result;
    }											      char *ptr;
    parray_insert(trie, search, nnode);							  
    return trie_insert(table, trie->children[search], str+1, tdat);			      ptr = &nterm[1];
}											      for (i = 0; ptr[i] != '>'; i++);
											      ptr[i] = '\0';
void parray_insert(idtnode_s *tnode, uint8_t index, idtnode_s *child)			      result = strcmp(ptr, str);
{											      ptr[i] = '>';
    uint8_t i, j, n;									      return result;
    idtnode_s **children;								  }
											  
    if (tnode->nchildren)								  int quote_strcmp(char *quoted, char *str)
	tnode->children = realloc(tnode->children, sizeof(*tnode->children) * (tnode->nch {
    else										      int i, result;
	tnode->children = malloc(sizeof(*tnode->children));				      char *ptr;
    children = tnode->children;								  
    n = tnode->nchildren - index;							      ptr = &quoted[1];
    for (i = 0, j = tnode->nchildren; i < n; i++, j--)					      for (i = 0; ptr[i] != '"'; i++);
	children[j] = children[j-1];							      ptr[i] = '\0';
    children[j] = child;								      result = strcmp(ptr, str);
    tnode->nchildren++;									      ptr[i] = '"';
}											      return result;







2014-02-11 02:00                                                                            lex.c                                                                            Page 13


}											      char *old;
											  
											      curr.n = 0;
void addmachine(lex_s *lex, token_s *tok)						      curr.stype = NULL;
{											      curr.attribute = 0;
    mach_s *nm;										      curr.success = false;
											      curr.overflow.str = NULL;
    nm = calloc(1, sizeof(*nm));							      curr.overflow.len = 0;
    if (!nm) {										      if (state == nfa->final)
	perror("Memory Allocation Error");						  	  curr.success = true;
	return;										      for (i = 0; i < state->nedges; i++) {
    }											  	  switch (state->edges[i]->token->type.val) {
    nm->nterm = tok;									  	      case LEXTYPE_EPSILON:
    nm->lexlen = MAX_LEXLEN;								  		  result = nfa_match(lex, nfa, state->edges[i]->state, buf, lineno);
    if (lex->machs)									  		  old = curr.stype;
	nm->next = lex->machs;								  
    lex->machs = nm;									  		  /********************************** POSSIBLE ISSUE NEEDING TO BE REVISITE
    lex->nmachs++;									  		  if (result.success && result.n >= curr.n /*Attribute type issue was fixed
}											  		      curr.success = true;
											  		      curr.stype = (state->edges[i]->annotation.type) ? state->edges[i]->an
int tokmatch(char *buf, token_s *tok, unsigned *lineno, bool negate)			  		      curr.attribute = (state->edges[i]->annotation.attribute > 0) ? state-
{											  		      if (result.n > curr.n)
    uint16_t i, len;									  			  curr.n = result.n;
    bool matched = true;								  		  }
											  		  break;
    if (*buf == EOF)									  	      case LEXTYPE_NONTERM:
	return EOF;									  		  tmp = getmach(lex, state->edges[i]->token->lexeme);
    if(tok->type.val == LEXTYPE_DOT)							  		  result = nfa_match(lex, tmp->nfa, tmp->nfa->start, buf, lineno);
	return 1;									  		  if (state->edges[i]->annotation.length > -1 && result.n > state->edges[i]
    len = strlen(tok->lexeme);								  		      result.overflow.str = state->edges[i]->token->lexeme;
    for (i = 0; i < len; i++) {								  		      result.overflow.len = result.n;
	if (buf[i] == EOF)								  		  }
	    return EOF;									  		  else if (result.success) {
	if (buf[i] != tok->lexeme[i]) {							  		      tmpmatch = result.n;
	    matched = false;								  		      result = nfa_match(lex, nfa, state->edges[i]->state, &buf[result.n],
	    break;									  		      if (result.success) {
	}										  			  curr.success = true;
    }											  			  if (result.n > 0 && result.attribute > 0)
    if (matched) {									  			      curr.attribute = result.attribute;
	if(negate)									  			  else if (tmpmatch > 0 && state->edges[i]->annotation.attribute >
	    return 0;									  			      curr.attribute = state->edges[i]->annotation.attribute;
	return len;									  			  if (state->edges[i]->annotation.type)
    }											  			      curr.stype = state->edges[i]->annotation.type;
    else {										  			  if (result.n + tmpmatch > curr.n)
	if(negate)									  			      curr.n = result.n + tmpmatch;
	    return len;									  		      }
	return 0;									  		  }
    }											  		  break;
}											  	      case LEXTYPE_TERM: /* case LEXTYPE_TERM */
											  	      case LEXTYPE_DOT:
match_s nfa_match(lex_s *lex, nfa_s *nfa, nfa_node_s *state, char *buf, unsigned *lineno) 		  tmatch = tokmatch(buf, state->edges[i]->token, lineno, state->edges[i]->n
{											  		  if (tmatch && tmatch != EOF) {
    size_t tmatch, tmpmatch;								  		      result = nfa_match(lex, nfa, state->edges[i]->state, &buf[tmatch], li
    uint16_t i;										  		      if (result.success) {
    mach_s *tmp;									  			  curr.success = true;
    match_s curr, result;								  







2014-02-11 02:00                                                                            lex.c                                                                            Page 14


			curr.attribute = (state->edges[i]->annotation.attribute > 0) ? st 	  if (*buf == EOF)
			curr.stype = (state->edges[i]->annotation.type) ? state->edges[i] 	      break;
			if (result.n + tmatch > curr.n)					  	  for (mach = lex->machs; mach; mach = mach->next) {
			    curr.n = result.n + tmatch;					  	      if (*buf == EOF)
		    }									  		  break;
		}									  	      res = nfa_match(lex, mach->nfa, mach->nfa->start, buf, &lineno);
		break;									  	      if (mach->unlimited || (!res.overflow.str &&  res.n <= mach->lexlen)) {
	    default:									  		  if (res.success && !mach->composite && res.n > best.n) {
		perror("Illegal State in nfa");						  		      best = res;
		assert(false);								  		      bmach = mach;
		break;									  		  }
	}										  	      }
    }											  	      else {
    return curr;									  		  if (mach->unlimited || !res.overflow.str) {
}											  		      overflow.str = buf;
											  		      overflow.len = res.n;
lextok_s lexf(lex_s *lex, char *buf, uint32_t linestart, bool listing)			  		      best.success = false;
{											  		  }
    int lcheck;										  		  else
    bool unlimited;									  		      overflow = res.overflow;
    int idatt = 0;									  	      }
    mach_s *mach, *bmach;								  	  }
    match_s res, best;									  	  for(lcheck = 0; lcheck < best.n; lcheck++) {
    unsigned lineno = linestart;							  	      if(buf[lcheck] == '\n')
    char c[2], *backup, *error, tmpbuf[MAX_LEXLEN];					  		  lineno++;
    tlookup_s lookup;									  	  }
    token_s *head = NULL, *tlist = NULL;						  	  unlimited = bmach ? bmach->unlimited : false;
    overflow_s overflow;								  	  c[0] = buf[best.n];
    sem_type_s init_type;;								  	  buf[best.n] = '\0';
											  	  if (best.success) {
    c[1] = '\0';									  	      if (unlimited || best.n <= bmach->lexlen) {
    backup = buf;									  		  lookup = idtable_lookup(lex->kwtable, buf);
    init_type.type = ATTYPE_NULL;							  		  if (lookup.is_found) {
    if (listing && *buf != EOF) {							  		      addtok_(&tlist, buf, lineno, lookup.tdat.itype, best.attribute, best.
	addline(&lex->listing, buf);							  		      hashname(lex, lookup.tdat.itype, buf);
	lineno++;									  		  }
    }											  		  else {
    while (*buf != EOF) {								  		      lookup = idtable_lookup(lex->idtable, buf);
	best.attribute = 0;								  		      if (lookup.is_found) {
	best.n = 0;									  			  addtok_(&tlist, buf, lineno, lookup.tdat.itype, lookup.tdat.att,
	best.success = false;								  			  hashname(lex, lookup.tdat.itype, buf);
	best.stype = NULL;								  		      }
	overflow.str = NULL;								  		      else if (bmach->attr_id) {
	overflow.len = 0;								  			  idatt++;
	bmach = NULL;									  			  addtok_(&tlist, buf, lineno, bmach->nterm->type.val, idatt, best.
											  			  idtable_insert(lex->idtable, buf, (tdat_s){.is_string = false, .i
	while (isspace(*buf)) {								  			  hashname(lex, lex->typestart, bmach->nterm->lexeme);
	    if (*buf == '\n') {								  		      }
		lineno++;								  		      else {
		if (listing)								  			  addtok_(&tlist, buf, lineno, bmach->nterm->type.val, best.attribu
		    addline(&lex->listing, buf+1);					  			  hashname(lex, lex->typestart, bmach->nterm->lexeme);
	    }										  		      }
	    else if (*buf == EOF)							  		  }
		break;									  		  if (!head)
	    buf++;									  		      head = tlist;
	}										  	      }







2014-02-11 02:00                                                                            lex.c                                                                            Page 15


	    else {									      return (lextok_s){.lex = lex, .lines = lineno, .tokens = head};
		addtok_(&tlist, c, lineno, LEXTYPE_ERROR, LEXATTR_DEFAULT, best.stype, un }
		if (listing) {								  
		    error = make_lexerr(LERR_TOOLONG, lineno, buf);			  char *make_lexerr(const char *errmsg, int lineno, char *lexeme)
		    adderror(lex->listing, error, lineno);				  {
		}									      char *error;
	    }										      size_t errsize;
	}										  
	else if (overflow.str) {							      errsize = strlen(errmsg) + strlen(lexeme) + INT_CHAR_WIDTH;
	    buf[best.n] = c[0];								      error = calloc(1, errsize);
	    c[0] = buf[overflow.len];							      if (!error) {
	    buf[overflow.len] = '\0';							  	  perror("Memory Allocation Error");
	    memset(tmpbuf, 0, sizeof(tmpbuf));						  	  exit(EXIT_FAILURE);
	    snprintf(tmpbuf, MAX_LEXLEN, "%s", buf);					      }
	    addtok(&tlist, tmpbuf, lineno, LEXTYPE_ERROR, LEXATTR_DEFAULT, best.stype);	      sprintf(error, errmsg, lineno, lexeme);
	    if (listing)								      error[errsize-1] = '\n';
		adderror(lex->listing, make_lexerr (LERR_TOOLONG, lineno, buf), lineno);      return error;
	    best.n = overflow.len;							  }
	}										  
	else {										  mach_s *getmach(lex_s *lex, char *id)
	    lookup = idtable_lookup(lex->kwtable, c);					  {
	    if (lookup.is_found) {							      mach_s *iter;
		addtok_(&tlist, c, lineno, lookup.tdat.itype, LEXATTR_DEFAULT, best.stype 
		hashname(lex, lookup.tdat.itype, NULL);					      for (iter = lex->machs; iter && strcmp(iter->nterm->lexeme, id); iter = iter->next);
		if (!head)								      if (!iter) {
		    head = tlist;							  	  fprintf(stderr, "Regex Error: Regex %s never defined", id);
	    }										  	  exit(EXIT_FAILURE);
	    else {									      }
		if (best.n) {								      return iter;
		    addtok(&tlist, c, lineno, LEXTYPE_ERROR, LEXATTR_DEFAULT, best.stype) }
		    if (listing) {							  
			assert(*buf != EOF);						  void settype(lex_s *lex, char *id, sem_type_s type)
			error = make_lexerr(LERR_UNKNOWNSYM, lineno, buf);		  {
			adderror(lex->listing, error, lineno);				     /* tdat_s tdat;
		    }									  
		}									      tdat = idtable_lookup(lex->idtable, id).tdat;
		else {									      tdat.type = type;
		    addtok(&tlist, c, lineno, LEXTYPE_ERROR, LEXATTR_DEFAULT, best.stype)     idtable_set(lex->idtable, id, tdat);*/
		    if (listing) {							      check_id_s check = check_id(id);
			assert(c[0] != EOF);						  
			error = make_lexerr(LERR_UNKNOWNSYM, lineno, c);		      if(check.isfound)
			adderror(lex->listing, error, lineno);				  	  *check.type = type;
		    }									  }
		}									  
	    }										  sem_type_s gettype(lex_s *lex, char *id)
	}										  {
	buf[best.n] = c[0];								      check_id_s check;
	if (best.n)									      sem_type_s init = {0};
	    buf += best.n;								  
	else										      init.type = ATTYPE_NULL;
	    buf++;									      check = check_id(id);
    }											      if(check.isfound)
    addtok(&tlist, "$", lineno, LEXTYPE_EOF, LEXATTR_DEFAULT, best.stype);		  	  return *check.type;
    if (!head)										      return init;
	head = tlist;									  }
    hashname(lex, LEXTYPE_EOF, "$");							  







2014-02-11 02:00                                                                            lex.c                                                                            Page 16


toktype_s gettoktype(lex_s *lex, char *id)						  {
{											      mach_s *m;
    toktype_s type;									      unsigned dummy = 0;
    size_t len;										      match_s match;
    lextok_s ltok;									      regex_match_s ret = (regex_match_s){.matched = false, .attribute = 0};
    token_s *iter;									  
											      for(m = lex->machs; m; m = m->next) {
    len = strlen(id);									  	  if(!ntstrcmp(m->nterm->lexeme, machid)) {
    id[len] = EOF;									  	      match = nfa_match(lex, m->nfa, m->nfa->start, str, &dummy);
    ltok = lexf(lex, id, 1, false);							  	      return (regex_match_s){.matched = match.success, .attribute = match.attribute
    id[len] = '\0';									  	  }
    type.val = LEXTYPE_ERROR;								  
    type.attribute = LEXATTR_DEFAULT;							      }
    for (iter = ltok.tokens; iter; iter = iter->next) {					      return ret;
	if (iter->type.val == LEXTYPE_ERROR || iter->type.val == LEXTYPE_EOF)		  }
	    continue;									  
	type = iter->type;								  void push_scope(char *id)
    }											  {
    iter = ltok.tokens;									      scope_s *s;
    return type;									      sem_type_s init = {0};
}											  
											      init.type = ATTYPE_NOT_EVALUATED;
inline bool hashname(lex_s *lex, unsigned long token_val, char *name)			      s = calloc(1, sizeof(*s));
{											      if(!s) {
    return hashinsert(lex->tok_hash, (void *)token_val, name);				  	  perror("Memory Allocation Error");
}											  	  exit(EXIT_FAILURE);
											      }
inline char *getname(lex_s *lex, unsigned long token_val)				      s->id = id;
{											      s->parent = scope_tree;
    return hashlookup(lex->tok_hash, (void *)token_val);				      s->last_arg_addr = -INTEGER_WIDTH;
}											      s->code = linetable_s_();
											  
int addtok_(token_s **tlist, char *lexeme, uint32_t lineno, uint16_t type, uint16_t attri     if(!scope_tree)
{											  	  scope_root = scope_tree = s;
    int ret;										      else {
    char buf[MAX_LEXLEN+1], *backup = lexeme;						  	  if(scope_tree->nchildren)
											  	      scope_tree->children = realloc(scope_tree->children, (scope_tree->nchildren +
    if (unlimited) {									  	  else
	if(strlen(lexeme) >= MAX_LEXLEN) {						  	      scope_tree->children = malloc(sizeof(*scope_tree->children));
	    snprintf(buf, MAX_LEXLEN, "%s", lexeme);					  	  if(!scope_tree->children) {
	    lexeme = buf;								  	      perror("Memory Allocation Error");
	}										  	      exit(EXIT_FAILURE);
	ret = addtok(tlist, lexeme, lineno, type, attribute, stype);			  	  }
	(*tlist)->lexeme_ = malloc(strlen(backup)+1);					  	  scope_tree->children[scope_tree->nchildren].child = s;
	if (!(*tlist)->lexeme_) {							  	  scope_tree->children[scope_tree->nchildren++].type = init;
	    perror("Memory Allocation Error");						  	  scope_tree = s;
	    exit(EXIT_FAILURE);								      }
	}										  }
	snprintf((*tlist)->lexeme_, strlen(backup)+1, "%s", backup);			  
    }											  void pop_scope(void)
    else										  {
	ret = addtok(tlist, lexeme, lineno, type, attribute, stype);			      if(scope_tree && scope_tree->parent)
    return ret;										  	  scope_tree = scope_tree->parent;
}											  }
											  
regex_match_s lex_matches(lex_s *lex, char *machid, char *str)				  check_id_s check_id(char *id)







2014-02-11 02:00                                                                            lex.c                                                                            Page 17


{											  	  scope_tree->entries = malloc(sizeof(*scope_tree->entries));
    unsigned i;										      if(!scope_tree->entries) {
    scope_s *iter;									  	  perror("Memory Allocation Error");
											  	  exit(EXIT_FAILURE);
    for(iter = scope_tree; iter; iter = iter->parent) {					      }
	for(i = 0; i < iter->nentries; i++) {						      scope_tree->entries[index].entry = id;
	    if(!strcmp(iter->entries[i].entry, id))					      scope_tree->entries[index].type = type;
		return (check_id_s){							      if(type.type == ATTYPE_ID) {
		    .isfound = true,							  	  if(!strcmp(type.str_, "integer")) {
		    .address = iter->entries[i].address,				  	      if(islocal) {
		    .scope = iter,							  		  scope_tree->entries[index].address = scope_tree->last_local_addr;
		    .width = iter->entries[i].width,					  		  scope_tree->entries[index].width = INTEGER_WIDTH;
		    .type = &iter->entries[i].type					  		  scope_tree->last_local_addr += INTEGER_WIDTH;
		};									  	      }
	}										  	      else {
	for(i = 0; i < iter->nchildren; i++) {						  		  scope_tree->entries[index].address = scope_tree->last_arg_addr;
	    if(!strcmp(iter->children[i].child->id, id)) {				  		  scope_tree->entries[index].width = INTEGER_WIDTH;
		return (check_id_s){							  		  scope_tree->last_arg_addr -= INTEGER_WIDTH;
		    .isfound = true,							  	      }
		    .address = 0,							  	  }
		    .scope = iter->children[i].child,					  	  else if(!strcmp(type.str_, "real")) {
		    .width = 0,								  	      if(islocal) {
		    .type = &iter->children[i].type					  		  scope_tree->entries[index].address = scope_tree->last_local_addr;
		};									  		  scope_tree->entries[index].width = REAL_WIDTH;
	    }										  		  scope_tree->last_local_addr += REAL_WIDTH;
	}										  	      }
    }											  	      else {
    return (check_id_s){.isfound = false, .address = 0, .scope = iter, .type = NULL};	  		  scope_tree->entries[index].address = scope_tree->last_arg_addr;
}											  		  scope_tree->entries[index].width = REAL_WIDTH;
											  		  scope_tree->last_arg_addr -= REAL_WIDTH;
bool check_redeclared(char *id)								  	      }
{											  	  }
    unsigned i;										  	  else {
											  	      scope_tree->entries[index].address = 0;
    if(!scope_tree)									  	  }
	return false;									      }
    for(i = 0; i < scope_tree->nentries; i++) {						      else if(type.type == ATTYPE_ARRAY) {
	if(!strcmp(scope_tree->entries[i].entry, id))					  	  difference = type.high - type.low;
	    return true;								  	  if(difference < 0)
    }											  	      difference = 0;
    for(i = 0; i < scope_tree->nchildren; i++) {					  	  if(!strcmp(type.str_, "integer")) {
	if(!strcmp(scope_tree->children[i].child->id, id))				  	      if(islocal) {
	    return true;								  		  scope_tree->entries[index].address = scope_tree->last_local_addr;
    }											  		  scope_tree->entries[index].width = INTEGER_WIDTH;
    return false;									  		  scope_tree->last_local_addr += INTEGER_WIDTH*difference;
}											  	      }
											  	      else {
void add_id(char *id, sem_type_s type, bool islocal)					  		  scope_tree->entries[index].address = scope_tree->last_arg_addr;
{											  		  scope_tree->entries[index].width = INTEGER_WIDTH;
    long difference;									  		  scope_tree->last_arg_addr -= INTEGER_WIDTH*difference;
    unsigned index;									  	      }
											  	  }
    index = scope_tree->nentries;							  	  else if(!strcmp(type.str_, "real")) {
    if(scope_tree->nentries)								  	      if(islocal) {
	scope_tree->entries = realloc(scope_tree->entries, (index + 1) * sizeof(*scope_tr 		  scope_tree->entries[index].address = scope_tree->last_local_addr;
    else										  		  scope_tree->entries[index].width = REAL_WIDTH;







2014-02-11 02:00                                                                            lex.c                                                                            Page 18


		scope_tree->last_local_addr += REAL_WIDTH*difference;			  	  print_indent(f);
	    }										  	  fprintf(f, "\t%16s: %8d\n", entries[i].entry, STACK_DIRECTION * entries[i].addres
	    else {									  	  if(i + 1  < s->nentries && entries[i+1].address == 0){
		scope_tree->entries[index].address = scope_tree->last_arg_addr;		  	      print_indent(f);
		scope_tree->entries[index].width = REAL_WIDTH;				  	      fputs("=================================================\n", f);
		scope_tree->last_arg_addr -= REAL_WIDTH*difference;			  	  }
	    }										  	  else{
	}										  	      print_indent(f);
	else {										  	      fputs("-------------------------------------------------\n", f);
	    scope_tree->entries[index].address = 0;					  	  }
	}										  #endif
    }											      }
    scope_tree->nentries++;								  #ifdef SHOW_PARAMETER_ADDRESSES
}											      print_indent(f);
											      fputs("\t\t<Frame Pointer>\n", f);
int entry_cmp(const void *a, const void *b)						      print_indent(f);
{											      fputs("=================================================\n", f);
    scope_entry_s   *aa = (scope_entry_s *)a,						  #endif
		    *bb = (scope_entry_s *)b;						      while(i < s->nentries) {
											  	  print_indent(f);
    if(aa->address > bb->address)							  	  fprintf(f, "\t%16s:  %8d\n", entries[i].entry, STACK_DIRECTION * entries[i].addre
	return 1;									  	  print_indent(f);
    if(aa->address < bb->address)							  	  if(i < s->nentries-1)
	return -1;									  	      fputs("-------------------------------------------------\n", f);
    return 0;										  	  else
}											  	      fputs("=================================================\n", f);
											  	  i++;
void print_indent(FILE *f)								      }
{											  }
    unsigned i;										  
											  void print_scope_(scope_s *root, FILE *f)
    for(i = 0; i < scope_indent; i++)							  {
	fputc('\t', f);									      unsigned i;
}											  
											      if(!root)
void print_frame(FILE *f, scope_s *s)							  	  return;
{											      print_frame(f, root);
    unsigned i;										      for(i = 0; i < root->nchildren; i++) {
    scope_entry_s entries[s->nentries];							  	  scope_indent++;
											  	  print_indent(f);
    print_indent(f);									  	  fputs("|\n", f);
    fputs("=================================================\n", f);			  	  print_indent(f);
    print_indent(f);									  	  fputs("|\n", f);
    fputs("=================================================\n", f);			  	  print_scope_(root->children[i].child, f);
    print_indent(f);									  	  scope_indent--;
    fprintf(f, "\tPrinting Addresses for Frame: %s\n", s->id);				      }
    print_indent(f);									  }
    fputs("=================================================\n", f);			  
    for(i = 0; i < s->nentries; i++)							  void print_scope(void *stream)
	entries[i] = s->entries[i];							  {
    qsort(entries, s->nentries, sizeof(*entries), entry_cmp);				      scope_indent = 0;
    for(i = 0; i < s->nentries; i++) {							      fputs("---Printing Scope Information---\n", (FILE *)stream);
	if(entries[i].address == 0)							      print_scope_(scope_root, stream);
	    break;									  }
#ifdef SHOW_PARAMETER_ADDRESSES








2014-02-06 01:43                                                                           parse.h                                                                            Page 1


/*											      llist_s *follows;
 parse.h										  };
 Author: Jonathan Hamm									  
											  struct production_s
 Description:										  {
    Library for parser generator. This reads in a specified Backus-Naur			      int nnodes;
    form and source file. The source file's syntax is checked in			      pnode_s *start;
    conformance to the specified LL(1) grammar.						      token_s *annot;
 */											      struct semantics_s *s;
											  };
#ifndef PARSE_H_									  
#define PARSE_H_									  struct pnode_s
											  {
#include "lex.h"									      pnode_s *self;
#include "general.h"									      token_s *token;
#include <stdio.h>									      token_s *matched;
											      token_s *annotation;
											      pnode_s *next;
#define PDATABLE_SIZE 19								      pnode_s *prev;
											      bool pass;
typedef struct parse_s parse_s;								      struct semantics_s *in;
typedef struct pda_s pda_s;								      struct semantics_s *syn;
typedef struct production_s production_s;						  };
typedef struct pnode_s pnode_s;								  
typedef struct parsetable_s parsetable_s;						  struct parsetable_s
											  {
struct parse_s										      uint16_t n_terminals;
{											      uint16_t n_nonterminals;
    lex_s *lex;										      token_s **terms;
    pda_s *start;									      token_s **nterms;
    hash_s *phash;									      int32_t **table;
    linetable_s *listing;								  };
    parsetable_s *parse_table;								  
};											  extern token_s *tok_lastmatched;
											  
struct pda_s										  extern parse_s *build_parse(const char *file, lextok_s lextok);
{											  extern pda_s *get_pda(parse_s *parser, char *name);
    token_s *nterm;									  extern bool hash_pda(parse_s *parser, char *name, pda_s *pda);
    uint16_t nproductions;								  extern void parse(parse_s *parse, lextok_s lex, FILE *out);
    production_s *productions;								  
    llist_s *firsts;									  #endif






















2014-02-11 02:00                                                                           parse.c                                                                            Page 1


/*											      token_s *token;
 parse.C										  };
 Author: Jonathan Hamm									  
											  extern FILE *emitdest;
 Description:										  token_s *tok_lastmatched;
    Implementation of parser generator. This reads in a specified Backus-Naur		  
    form and source file. The source file's syntax is checked in			  static void match_phase(lextok_s regex, token_s *cfg);
    conformance to the specified LL(1) grammar.						  static tfind_s findtok(mach_s *mlist, char *lexeme);
 */											  static parse_s *parse_(void);
											  static pda_s *pda_(token_s *token);
#include "general.h"									  static production_s *addproduction(pda_s *pda);
#include "parse.h"									  static pnode_s *pnode_(token_s *token);
#include "semantics.h"									  
#include <stdio.h>									  static void pp_start(parse_s *parse, token_s **curr);
#include <string.h>									  static void pp_nonterminal(parse_s *parse, token_s **curr);
#include <stdlib.h>									  static void pp_nonterminals(parse_s *parse, token_s **curr);
#include <math.h>									  static void pp_production(parse_s *parse, token_s **curr, pda_s *pda);
#include <pthread.h>									  static void pp_productions(parse_s *parse, token_s **curr, pda_s *pda);
											  static pnode_s *pp_tokens(parse_s *parse, token_s **curr, pda_s *pda, int *count);
#define INIT_SYNERRSIZE 64								  static void pp_decoration(parse_s *parse, token_s **curr, production_s *prod);
#define SYNERR_PREFIX "	     --Syntax Error at line %u: Expected "			  
#define PANIC_NOANNOTATION (void *)curr							  static ffnode_s *makeffnode (token_s *token, uint16_t prod);
											  static bool isespsilon(production_s *production);
#define LLFF(node) ((ffnode_s *)node->ptr)						  static bool hasepsilon(parse_s *parser, pnode_s *nonterm);
#define LLTOKEN(node ) (LLFF(node)->token)						  static llist_s *clone_firsts(llist_s *firsts, int production);
											  static llist_s *getfirsts(parse_s *parser, pda_s *pda);
typedef struct follow_s follow_s;							  static void getfollows(follow_s *fparams);
typedef struct ffnode_s ffnode_s;							  static inline ffnode_s *makeEOF(void);
typedef struct tfind_s tfind_s;								  static inline token_s *tmakeEOF(void);
											  static follow_s *get_neighbor_params (follow_s *table, pda_s *pda);
struct follow_s										  static llist_s *lldeep_concat_foll (llist_s *first, llist_s *second);
{											  static bool llpnode_contains(llist_s *list, token_s *tok);
    pda_s *pda;										  static void add_inherit(follow_s *nonterm, follow_s *dependent);
    parse_s *parser;									  static llist_s *inherit_follows(follow_s *params, llist_s **stack);
    uint16_t index;									  static void compute_firstfollows(parse_s *parser);
    pthread_t thread;									  
    follow_s *table;									  static bool lllex_contains(llist_s *list, char *lex);
    llist_s *firsts;									  static void build_parse_table(parse_s *parse, token_s *tokens);
    llist_s *follows;									  static void print_parse_table(parsetable_s *ptable, FILE *stream);
    uint16_t *count;									  static void print_firfol(parse_s *parse, FILE *stream);
    bool *ready;									  
    pthread_mutex_t *jlock;								  static int match(token_s **curr, pnode_s *p);
    pthread_cond_t *jcond;								  static semantics_s *nonterm(parse_s *parse, semantics_s *in, pnode_s *pnterm, mach_s *mac
    uint16_t ninherit;									  static int get_production(parsetable_s *ptable, pda_s *pda, token_s **curr);
    follow_s **inherit;									  static size_t errbuf_check(char **buffer, size_t *bsize, size_t *errsize, char *lexeme);
};											  static char *make_synerr(pda_s *pda, token_s **curr);
											  static void panic_recovery(llist_s *follow, token_s **curr);
struct ffnode_s										  static void print_pnode_hash(void *key, void *data);
{											  
    uint16_t prod;									  static uint16_t str_hashf(void *key);
    token_s *token;									  static bool find_in(void *k1, void *k2);
};											  
											  void printpda(pda_s *start)
struct tfind_s										  {
{											      int i;
    bool found;										      pnode_s *iter;







2014-02-11 02:00                                                                           parse.c                                                                            Page 2


											  		  cfg = cfg->next;
    for (i = 0; i < start->nproductions; i++) {						  	      }
	printf("\nnew production\n");							  	      while (cfg->type.val != LEXTYPE_EOF);
	for (iter = start->productions[i].start; iter; iter = iter->next)		  	  }
	    printf("%s\n", iter->token->lexeme);					  	  if (cfg->type.val == LEXTYPE_EPSILON) {
    }											  	      continue;
}											  	  }
											  	  tfind = findtok(regex.lex->machs, cfg->lexeme);
parse_s *build_parse(const char *file, lextok_s lextok)					  	  if (tfind.found)
{											  	      cfg->type.val = tfind.token->type.val;
    lex_s *semantics;									  	  else {
    parse_s *parse;									  	      type = gettoktype(regex.lex, cfg->lexeme);
    token_s *list, *head;								  	      if (type.val != LEXTYPE_ERROR)
    llist_s *firsts;									  		  cfg->type.val = type.val;
    FILE *fptable, *firfol;								  	  }
											      }
    fptable = fopen("parsetable", "w");							  }
    firfol = fopen("firstfollow", "w");							  
    if (!(fptable && firfol)) {								  tfind_s findtok(mach_s *mlist, char *lexeme)
	perror("File IO Error");							  {
	exit(EXIT_FAILURE);								      mach_s *idtype = NULL;
    }											  
    assert(idtable_lookup(lextok.lex->kwtable, ")").is_found);				      while (mlist) {
											  	  if (!ntstrcmp(mlist->nterm->lexeme, lexeme))
    semantics = semant_init();								  	      return (tfind_s){.found = true, .token = mlist->nterm};
    list = lexspec(file, cfg_annotate, semantics, false);				  	  if (mlist->attr_id)
    head = list;									  	      idtype = mlist;
    parse = parse_();									  	  mlist = mlist->next;
    parse->listing = lextok.lex->listing;						      }
    pp_start(parse, &list);								      if (idtype)
    compute_firstfollows(parse);							  	  return (tfind_s){.found = false, .token = idtype->nterm};
    firsts = getfirsts(parse, get_pda(parse, parse->start->nterm->lexeme));		      return (tfind_s){.found = false, .token = NULL};
    build_parse_table(parse, head);							  }
    print_parse_table(parse->parse_table, fptable);					  
    print_firfol(parse, firfol);							  parse_s *parse_(void)
    fclose(fptable);									  {
    fclose(firfol);									      parse_s *parse;
    match_phase(lextok, head);								  
    parse->lex = lextok.lex;								      parse = malloc(sizeof(*parse));
    return parse;									      if (!parse) {
}											  	  perror("Memory Allocation Error");
											  	  exit(EXIT_FAILURE);
void match_phase(lextok_s regex, token_s *cfg)						      }
{											      parse->start = NULL;
    toktype_s type;									      parse->phash = hash_(pjw_hashf, str_isequalf);
    mach_s *idmach = NULL;								      return parse;
    tfind_s tfind;									  }
											  
    assert(idtable_lookup(regex.lex->kwtable, "integer").is_found);			  pda_s *pda_(token_s *token)
    for (idmach = regex.lex->machs; idmach; idmach = idmach->next) {			  {
	if (idmach->attr_id)								      pda_s *pda;
	    break;									  
    }											      pda = malloc(sizeof(*pda));
    for (; cfg; cfg = cfg->next) {							      if (!pda) {
	if (cfg->type.val == LEXTYPE_ANNOTATE) {					  	  perror("Memory Allocation Error");
	    do {									  	  exit(EXIT_FAILURE);







2014-02-11 02:00                                                                           parse.c                                                                            Page 3


    }											  	  *curr = (*curr)->next;
    pda->nterm = token;									  	  if ((*curr)->type.val == LEXTYPE_PRODSYM) {
    pda->nproductions = 0;								  	      *curr = (*curr)->next;
    pda->productions = NULL;								  	      pp_production(parse, curr, pda);
    return pda;										  	      pp_productions(parse, curr, pda);
}											  	  }
											  	  else {
production_s *addproduction(pda_s *pda)							  	      fprintf(stderr, "Syntax Error at line %d: Expected '->' but got %s\n", (*curr
{											  	      assert(false);
    if (pda->productions)								  	  }
	pda->productions = realloc(pda->productions, sizeof(*pda->productions)*(pda->npro     }
    else										      else {
	pda->productions = malloc(sizeof(*pda->productions));				  	  fprintf(stderr, "Syntax Error at line %d: Expected nonterminal but got %s\n", (*c
    if (!pda->productions) {								  	  assert(false);
	perror("Memory Allocation Error");						      }
	exit(EXIT_FAILURE);								  }
    }											  
    pda->productions[pda->nproductions].annot = NULL;					  void pp_nonterminals(parse_s *parse, token_s **curr)
    pda->productions[pda->nproductions].s = NULL;					  {
    pda->productions[pda->nproductions].start = NULL;					      switch ((*curr)->type.val) {
    pda->productions[pda->nproductions].nnodes = 0;					  	  case LEXTYPE_EOL:
    return &pda->productions[pda->nproductions++];					  	      *curr = (*curr)->next;
}											  	      pp_nonterminal(parse, curr);
											  	      pp_nonterminals(parse, curr);
pnode_s *pnode_(token_s *token)								  	      break;
{											  	  case LEXTYPE_EOF:
    pnode_s *pnode;									  	      break;
											  	   default:
    pnode = calloc(1, sizeof(*pnode));							  	      fprintf(stderr, "Syntax Error at line %d: Expected EOL or $ but got %s\n", (*
    if (!pnode) {									  	      assert(false);
	perror("Memory Allocation Error");						  	      break;
	exit(EXIT_FAILURE);								      }
    }											  }
    pnode->self = pnode;								  
    pnode->token = token;								  void pp_production(parse_s *parse, token_s **curr, pda_s *pda)
    return pnode;									  {
}											      pnode_s *token;
											      production_s *production = NULL;
void pp_start(parse_s *parse, token_s **curr)						  
{											      switch ((*curr)->type.val) {
    pp_nonterminal(parse, curr);							  	  case LEXTYPE_DOT:
    pp_nonterminals(parse, curr);							  	  case LEXTYPE_TERM:
}											  	  case LEXTYPE_NONTERM:
											  	  case LEXTYPE_EPSILON:
void pp_nonterminal(parse_s *parse, token_s **curr)					  	      production = addproduction(pda);
{											  	      production->start = pnode_(*curr);
    pda_s *pda = NULL;									  	      production->nnodes++;
											  	      *curr = (*curr)->next;
    if ((*curr)->type.val == LEXTYPE_EOL)						  	      token = pp_tokens(parse, curr, pda, &production->nnodes);
	*curr = (*curr)->next;								  	      production->start->next = token;
    if ((*curr)->type.val == LEXTYPE_NONTERM) {						  	      pp_decoration(parse, curr, production);
	pda = pda_(*curr);								  	      break;
	if (!hash_pda(parse, (*curr)->lexeme, pda)) {					  	  default:
	    fprintf(stderr, "Error: Redefinition of production: %s\n", (*curr)->lexeme);  	      fprintf(stderr, "Syntax Error at line %d: Expected token but got %s\n", (*cur
	    assert(false);								  	      assert(false);
	}										  	      break;







2014-02-11 02:00                                                                           parse.c                                                                            Page 4


    }											      switch ((*curr)->type.val) {
}											  	  case LEXTYPE_ANNOTATE:
											  	      *curr = (*curr)->next;
void pp_productions(parse_s *parse, token_s **curr, pda_s *pda)				  	      prod->annot = *curr;
{											  	      assert(prod->annot->prev->type.val == LEXTYPE_ANNOTATE);
    switch ((*curr)->type.val) {							  	      while ((*curr)->type.val != LEXTYPE_EOF)
	case LEXTYPE_UNION:								  		  *curr = (*curr)->next;
	    *curr = (*curr)->next;							  	      *curr = (*curr)->next;
	    pp_production(parse, curr, pda);						  	      break;
	    pp_productions(parse, curr, pda);						  	  case LEXTYPE_UNION:
	    break;									  	  case LEXTYPE_NONTERM:
	case LEXTYPE_ANNOTATE:								  	  case LEXTYPE_EOL:
	case LEXTYPE_NONTERM:								  	  case LEXTYPE_EOF:
	case LEXTYPE_EOL:								  	      break;
	case LEXTYPE_EOF:								  	  default:
	    break;									  	      fprintf(stderr, "Syntax Error at line %d: Expected annotation, nonterm, or $,
	default:									  	      assert(false);
	    fprintf(stderr, "Syntax Error at line %d: Expected '|', annotation, nonterm,  	      break;
	    assert(false);								      }
	    break;									  }
    }											  
}											  ffnode_s *makeffnode(token_s *token, uint16_t prod)
											  {
pnode_s *pp_tokens(parse_s *parse, token_s **curr, pda_s *pda, int *count)		      ffnode_s *ffnode;
{											  
    pnode_s *pnode = NULL, *token;							      ffnode = malloc(sizeof(*ffnode));
											      if (!ffnode) {
    switch ((*curr)->type.val) {							  	  perror("Memory Allocation Error");
	case LEXTYPE_DOT:								  	  exit(EXIT_FAILURE);
	case LEXTYPE_TERM:								      }
	case LEXTYPE_NONTERM:								      ffnode->token = token;
	case LEXTYPE_EPSILON:								      ffnode->prod = prod;
	    pnode = pnode_(*curr);							      return ffnode;
	    ++*count;									  }
	    *curr = (*curr)->next;							  
	    token = pp_tokens(parse, curr, pda, count);					  bool isespsilon(production_s *production)
	    if (token) {								  {
		pnode->next = token;							      return production->start->token->type.val == LEXTYPE_EPSILON && !production->start->n
		token->prev = pnode;							  }
	    }										  
	    break;									  bool hasepsilon(parse_s *parser, pnode_s *nonterm)
	case LEXTYPE_ANNOTATE:								  {
	case LEXTYPE_UNION:								      pda_s *pda;
	case LEXTYPE_EOL:								      uint16_t i;
	case LEXTYPE_EOF:								  
	    break;									      if (!nonterm || nonterm->token->type.val == LEXTYPE_TERM || nonterm->token->type.val
	default:									  	  return false;
	    fprintf(stderr, "Syntax Error at line %d: Expected token, annotation, nonterm     pda = get_pda(parser, nonterm->token->lexeme);
	    assert(false);								      assert(pda);
	    break;									      for (i = 0; i < pda->nproductions; i++) {
    }											  	  if (isespsilon(&pda->productions[i]))
    return pnode;									  	      return true;
}											      }
											      return false;
void pp_decoration(parse_s *parse, token_s **curr, production_s *prod)			  }
{											  







2014-02-11 02:00                                                                           parse.c                                                                            Page 5


llist_s *clone_firsts(llist_s *firsts, int production)					      pda_s *pda, *nterm;
{											      pnode_s *iter;
    llist_s *new = NULL, *start = NULL;							      hrecord_s *curr;
											      follow_s *neighbor;
    if (firsts) {									      hashiterator_s *iterator;
	new = llcopy(firsts);								  
	start = new;									      if (fparams->pda == fparams->parser->start) {
	LLFF(new)->prod = production;							  	  tmpeof = makeEOF();
	firsts = firsts->next;								  	  if (!llpnode_contains(fparams->follows, tmpeof->token))
	while (firsts) {								  	      llpush(&fparams->follows, tmpeof);
	    new->next = llcopy(firsts);							  	  else
	    firsts = firsts->next;							  	      free(tmpeof);
	    new = new->next;								      }
	    LLFF(new)->prod = production;						      iterator = hashiterator_(fparams->parser->phash);
	}										      for (curr = hashnext(iterator); curr; curr = hashnext(iterator)) {
    }											  	  pda = curr->data;
											  	  for (i = 0; i < pda->nproductions; i++) {
    assert(start);									  	      for (iter = pda->productions[i].start; iter; iter = iter->next) {
    return start;									  		  if (get_pda(fparams->parser, iter->token->lexeme) == fparams->pda) {
}											  		      do {
											  			  if (!iter->next) {
											  			      has_epsilon = false;
llist_s *getfirsts(parse_s *parser, pda_s *pda)						  			      neighbor = get_neighbor_params(fparams->table, pda);
{											  			      add_inherit(fparams, neighbor);
    uint16_t i;										  			  }
    pda_s *tmp;										  			  else {
    pnode_s *iter;									  			      iter = iter->next;
    llist_s *list = NULL;								  			      has_epsilon = hasepsilon(fparams->parser, iter);
											  			      if (iter->token->type.val == LEXTYPE_TERM || iter->token->typ
    for (i = 0; i < pda->nproductions; i++) {						  				  if (!llpnode_contains(fparams->follows, iter->token))
	if (isespsilon(&pda->productions[i]))						  				      llpush(&fparams->follows, makeffnode(iter->token, 0))
	    llpush(&list, makeffnode(pda->productions[i].start->token, i));		  			      }
	else {										  			      else {
	    iter = pda->productions[i].start;						  				  nterm = get_pda(fparams->parser, iter->token->lexeme);
	    if (!iter)									  				  neighbor = get_neighbor_params(fparams->table, nterm);
		return NULL;								  				  fparams->follows = lldeep_concat_foll(fparams->follows, n
	    do {									  				  if (has_epsilon)
		if (iter->token->type.val == LEXTYPE_TERM || iter->token->type.val == LEX 				      add_inherit(fparams, neighbor);
		    llpush(&list, makeffnode(iter->token, i));				  			      }
		else {									  			  }
		    tmp = get_pda(parser, iter->token->lexeme);				  		      }
		    assert(tmp);							  		      while (has_epsilon);
		    list = llconcat(list, clone_firsts(getfirsts(parser, tmp), i));	  		  }
		}									  	      }
	    }										  	  }
	    while (hasepsilon(parser, iter) && (iter = iter->next));			      }
	}										  
    }											      pthread_mutex_lock(fparams->jlock);
    return list;									      --*fparams->count;
}											      pthread_cond_signal(fparams->jcond);
											      pthread_mutex_unlock(fparams->jlock);
void getfollows(follow_s *fparams)							  
{											      free(iterator);
    uint16_t i;										      pthread_exit(0);
    bool has_epsilon;									  }
    ffnode_s *tmpeof;									  







2014-02-11 02:00                                                                           parse.c                                                                            Page 6


inline ffnode_s *makeEOF (void)								      }
{											      return false;
    return makeffnode(tmakeEOF(), 1);							  }
}											  
											  void add_inherit(follow_s *nonterm, follow_s *dependent)
inline token_s *tmakeEOF(void)								  {
{											      uint16_t i;
    token_s *tok;									  
											      if (nonterm->ninherit)
    tok = calloc(1, sizeof(*tok));							  	  nonterm->inherit = realloc(nonterm->inherit, (nonterm->ninherit + 1) * sizeof(*no
    if (!tok) {										      else
	perror("Memory Allocation Error");						  	  nonterm->inherit = malloc(sizeof(*nonterm->inherit));
	exit(EXIT_FAILURE);								      if (!nonterm->inherit) {
    }											  	  perror("Memory Allocation Error");
    tok->lexeme[0] = '$';								  	  exit(EXIT_FAILURE);
    tok->type.val = LEXTYPE_EOF;							      }
    tok->type.attribute = LEXATTR_FAKEEOF;						      for (i = 0; i < nonterm->ninherit; i++) {
    return tok;										  	  if (nonterm->inherit[i] == dependent)
}											  	      return;
											      }
follow_s *get_neighbor_params(follow_s *table, pda_s *pda)				      nonterm->inherit[nonterm->ninherit] = dependent;
{											      nonterm->ninherit++;
    while (table->pda != pda)								  }
	table++;									  
    return table;									  llist_s *inherit_follows(follow_s *nterm, llist_s **stack)
}											  {
											      uint16_t i;
llist_s *lldeep_concat_foll(llist_s *first, llist_s *second)				      llist_s *tmp;
{											  
    llist_s *second_ = NULL, *iter = NULL;						      if (llcontains(*stack, nterm)) {
											  	  return NULL;
   if (!second)										      }
       return first;									      else
    while (LLTOKEN(second)->type.val == LEXTYPE_EPSILON ||				  	  llpush(stack, nterm);
	   llpnode_contains(first, LLTOKEN(second))) {					      for (i = 0; i < nterm->ninherit; i++) {
	second = second->next;								  	  nterm->follows = lldeep_concat_foll(nterm->follows, inherit_follows(nterm->inheri
	if (!second)									      }
	    return first;								      tmp = llpop(stack);
    }											      free(tmp);
    second_ = iter = llcopy(second);							      return nterm->follows;
    for (second = second->next; second; second = second->next) {			  }
	if (LLTOKEN(second)->type.val == LEXTYPE_EPSILON ||				  
	    llpnode_contains(first, LLTOKEN(second)))					  void compute_firstfollows(parse_s *parser)
	    continue;									  {
	iter->next = llcopy(second);							      bool ready = false;
	iter = iter->next;								      int i, status, nitems = parser->phash->nitems;
    }											      pda_s *tmp;
    return llconcat (first, second_);							      hrecord_s *curr;
}											      hashiterator_s *iterator;
											      follow_s ftable[nitems];
bool llpnode_contains(llist_s *list, token_s *tok)					      pthread_mutex_t jlock;
{											      pthread_cond_t jcond;
    while (list) {									      llist_s *stack = NULL;
	if (!strcmp(LLTOKEN(list)->lexeme, tok->lexeme))				      uint16_t threadcount = 0;
	    return true;								  
	list = list->next;								      memset(ftable, 0, sizeof(ftable));







2014-02-11 02:00                                                                           parse.c                                                                            Page 7


    nitems = parser->phash->nitems;							  
    status = pthread_mutex_init(&jlock, NULL);						  void build_parse_table(parse_s *parse, token_s *tokens)
    if (status) {									  {
	perror("Error: Failed to initialize mutex lock");				      uint16_t	  i, j, k,
	exit(status);									  		  n_terminals = 1,
    }											  		  n_nonterminals = 0;
    status = pthread_cond_init(&jcond, NULL);						      llist_s *terminals = NULL,
    if (status) {									  	      *nonterminals = NULL, *tmp;
	perror("Error: Failed to initialize condition variable");			      parsetable_s *ptable;
	exit(status);									      llist_s *first_iter, *foll_iter;
    }											      pda_s *curr;
    iterator = hashiterator_(parser->phash);						      hrecord_s *hcurr;
    for (curr = hashnext(iterator), i = 0; curr; curr = hashnext(iterator), i++) {	      hashiterator_s *hiterator;
	tmp = curr->data;								  
	tmp->firsts = getfirsts(parser, tmp);						      llpush(&terminals, tmakeEOF());
	ftable[i].parser = parser;							      while (tokens) {
	ftable[i].table = ftable;							  
	ftable[i].index = i;								  
	ftable[i].pda = curr->data;							  	  if (tokens->type.val == LEXTYPE_TERM || tokens->type.val == LEXTYPE_DOT) {
	ftable[i].firsts = tmp->firsts;							  	      if (!lllex_contains(terminals, tokens->lexeme)) {
	ftable[i].jlock = &jlock;							  		  llpush(&terminals, tokens);
	ftable[i].jcond = &jcond;							  		  n_terminals++;
	ftable[i].ready = &ready;							  	      }
	ftable[i].count = &threadcount;							  	  }
	ftable[i].ninherit = 0;								  	  else if (tokens->type.val == LEXTYPE_NONTERM) {
    }											  	      if (!lllex_contains(nonterminals, tokens->lexeme)) {
    free(iterator);									  		  llpush(&nonterminals, tokens);
    threadcount = nitems;								  		  n_nonterminals++;
    for (i = 0; i < nitems; i++) {							  	      }
	status = pthread_create(&ftable[i].thread, NULL, (void *(*)())getfollows, &ftable 	  }
	if (status) {									  	  tokens = tokens->next;
	    perror("Error: Could not start new thread");				      }
	    exit(status);								      ptable = malloc(sizeof(*ptable));
	}										      if (!ptable) {
    }											  	  perror("Memory Allocation Error");
											  	  exit(EXIT_FAILURE);
    pthread_mutex_lock(&jlock);								      }
    while(threadcount)									      ptable->n_terminals = n_terminals;
	pthread_cond_wait(&jcond, &jlock);						      ptable->n_nonterminals = n_nonterminals;
    pthread_mutex_unlock(&jlock);							      ptable->table = malloc(n_nonterminals * sizeof(*ptable->table));
											      if (!ptable->table) {
    for (i = 0; i < nitems; i++)							  	  perror("Memory Allocation Error");
	ftable[i].pda->follows = inherit_follows(&ftable[i], &stack);			  	  exit(EXIT_FAILURE);
    pthread_mutex_destroy(&jlock);							      }
    pthread_cond_destroy(&jcond);							      for (i = 0; i < n_nonterminals; i++) {
}											  	  ptable->table[i] = malloc(n_terminals * sizeof(**ptable->table));
											  	  if (!ptable->table[i]) {
bool lllex_contains(llist_s *list, char *lex)						  	      perror("Memory Allocation Error");
{											  	      exit(EXIT_FAILURE);
    while (list) {									  	  }
	if (!strcmp(((token_s *)list->ptr)->lexeme, lex))				  	  for (j = 0; j < n_terminals; j++)
	    return true;								  	      ptable->table[i][j] = -1;
	list = list->next;								      }
    }											      ptable->terms = calloc(sizeof(*ptable->terms), n_terminals);
    return false;									      ptable->nterms = calloc(sizeof(*ptable->nterms), n_nonterminals);
}											      if (!ptable->terms || !ptable->nterms) {







2014-02-11 02:00                                                                           parse.c                                                                            Page 8


	perror("Memory Allocation Error");						  	      else
	exit(EXIT_FAILURE);								  		  fprintf(stream, "%-31d | ", ptable->table[i][j]);
    }											  	  }
    for (i = 0; i < n_terminals; i++) {							      }
	tmp = llpop(&terminals);							      fprintf(stream, "\n");
	ptable->terms[i] = tmp->ptr;							  }
	free(tmp);									  
    }											  void print_firfol (parse_s *parse, FILE *stream)
    for (i = 0; i < n_nonterminals; i++) {						  {
	tmp = llpop(&nonterminals);							      llist_s *iter;
	ptable->nterms[i] = tmp->ptr;							      pda_s *curr;
	free(tmp);									      hrecord_s *hcurr;
    }											      hashiterator_s *hiter;
    hiterator = hashiterator_(parse->phash);						  
    for (hcurr = hashnext(hiterator); hcurr; hcurr = hashnext(hiterator)) {		      hiter = hashiterator_(parse->phash);
	curr = hcurr->data;								      for (hcurr = hashnext(hiter); hcurr; hcurr = hashnext(hiter)) {
	for (i = 0; i < n_nonterminals; i++) {						  	  curr = hcurr->data;
	    if (!strcmp(curr->nterm->lexeme, ptable->nterms[i]->lexeme))		  	  fprintf(stream, "%s:\nfirsts:\n\t", curr->nterm->lexeme);
		break;									  	  for (iter = curr->firsts; iter; iter = iter->next)
	}										  	      fprintf(stream, "%s\t", LLTOKEN(iter)->lexeme);
	 for (first_iter = curr->firsts; first_iter; first_iter = first_iter->next) {	  	  fprintf(stream, "\nfollows:\n\t");
	    for (j = 0; j < n_terminals; j++) {						  	  for (iter = curr->follows; iter; iter = iter->next)
		if (!strcmp(LLTOKEN(first_iter)->lexeme, ptable->terms[j]->lexeme))	  	      fprintf(stream, "%s\t", LLTOKEN(iter)->lexeme);
		    ptable->table[i][j] = LLFF(first_iter)->prod;			  	  fprintf(stream, "\n\n");
		else if (LLTOKEN(first_iter)->type.val == LEXTYPE_EPSILON) {		      }
		    for (foll_iter = curr->follows; foll_iter; foll_iter = foll_iter->nex     free(hiter);
			for (k = 0; k < n_terminals; k++) {				  }
			    if (!strcmp(LLTOKEN(foll_iter)->lexeme, ptable->terms[k]->lex 
				ptable->table[i][k] = LLFF(first_iter)->prod;		  
			    }								  void parse(parse_s *parse, lextok_s lex, FILE *out)
			}								  {
		    }									      int index;
		}									      size_t errsize;
	    }										      char *synerr;
	}										      pda_s *nterm;
    }											      pnode_s *root;
    parse->parse_table = ptable;							  
}											      emitdest = out;
											      root = pnode_(parse->start->nterm);
void print_parse_table (parsetable_s *ptable, FILE *stream)				      index = get_production(parse->parse_table, parse->start, &lex.tokens);
{											      if (index < 0) {
    uint16_t i, j, accum;								  	  nterm = get_pda(parse, parse->start->nterm->lexeme);
											  	  for (index = 0; parse->parse_table->nterms[index]->type.val != parse->start->nter
    fprintf(stream, "%-31s", " ");							  	  synerr = make_synerr (nterm, &lex.tokens);
    for (i = 0, accum = 0; i < ptable->n_terminals; i++) {				  	  adderror(parse->listing, synerr, lex.tokens->lineno);
	fprintf(stream, " | %-31s", ptable->terms[i]->lexeme);				  	  panic_recovery(parse->start->follows, &lex.tokens);
	accum += 35;									      }
    }											      root->in = NULL;
    fprintf(stream, "\n");								      nonterm(parse, NULL, root, lex.lex->machs, &lex.tokens, parse->start, index);
    for (i = 0; i < accum; i++)								      if (lex.tokens->type.val != LEXTYPE_EOF) {
	fprintf(stream, "-");								  	  errsize = (sizeof(SYNERR_PREFIX)-1)+FS_INTWIDTH_DEC(lex.tokens->lineno)+sizeof("E
    for (i = 0; i < ptable->n_nonterminals; i++) {					  	  synerr = malloc(errsize);
	fprintf(stream, "\n%-31s | ", ptable->nterms[i]->lexeme);			  	  if (!synerr) {
	for (j = 0; j < ptable->n_terminals; j++) {					  	      perror("Memory Allocation Error");
	    if (ptable->table[i][j] == -1)						  	      exit(EXIT_FAILURE);
		fprintf(stream, "%-31s | ", "NULL");					  	  }







2014-02-11 02:00                                                                           parse.c                                                                            Page 9


	sprintf(synerr, SYNERR_PREFIX "EOF but got %s", lex.tokens->lineno, lex.tokens->l 	  pcp->curr = pcp->array;
	synerr[errsize-1] = '\n';							  	  sem_start(NULL, parse, machs, pda, &pda->productions[index], pcp, synhash, ++pass
	adderror(parse->listing, synerr, lex.tokens->lineno);				  	  pnode->pass = true;
    }											  	  grstack_pop();
    write_code();									  	  return synhash;
}											      }
											      else {
int match(token_s **curr, pnode_s *p)							  	  for (i = 0; pnode; pnode = pnode->next, i++) {
{											  	      do {
    if ((*curr)->type.val == p->token->type.val) {					  		  if (!*curr)
	p->matched = *curr;								  		      return synhash;
	tok_lastmatched = *curr;							  		  success = true;
	if ((*curr)->type.val != LEXTYPE_EOF) {						  		  if ((nterm = get_pda(parse, pnode->token->lexeme))) {
	    *curr = (*curr)->next;							  		      result = get_production(parse->parse_table, nterm, curr);
	    return 1;									  		      if (result < 0) {
	}										  			  adderror(parse->listing, make_synerr(nterm, curr), (*curr)->linen
	return 2;									  			  success = NULL;
    }											  			  if ((*curr)->type.val == LEXTYPE_EOF) {
    return 0;										  			      grstack_pop();
}											  			      return NULL;
											  			  }
semantics_s *nonterm(parse_s *parse, semantics_s *in, pnode_s *pnterm, mach_s *machs, tok 			  *curr = (*curr)->next;
{											  		      }
    int result, i;									  		      else {
    pda_s *nterm;									  			  /*
    pnode_s *pnode;									  			   Problem: Synthesized attributes must be accessed by an array of
    bool success;									  			   hashes corresponding to each child nonterminal.
    char *synerr;									  			   */
    size_t errsize;									  			  pcp->curr = &pcp->array[i];
    pna_s *pcp, *synth;									  			  child_inll = sem_start(NULL, parse, machs, pda, &pda->productions
    llist_s *child_inll;								  			  child_in = llremove_(&child_inll, find_in, pnode);
    semantics_s *child_in;								  			  if(child_in) {
    semantics_s *synhash = semantics_s_(parse, machs);					  			      //print_hash(child_in->table, print_pnode_hash);
    synhash->n = pnterm;								  			      //puts("\n--\n");
    unsigned pass = 0;									  			      //print_pnode_hash
											  			  }
    assert(!pda->productions[index].annot || pda->productions[index].annot->prev->type.va 
											  			  pcp->curr->syn = nonterm(parse, child_in, pnode, machs, curr, nte
    grstack_push();									  			  pnode->pass = true;
											  			  sem_start(NULL, parse, machs, pda, &pda->productions[index], pcp,
    pcp = malloc(sizeof(*pcp) + pda->productions[index].nnodes * sizeof(pnode_s));	  		      }
    if(!pcp) {										  		  }
	perror("Memory Allocation Error");						  		  else {
	exit(EXIT_FAILURE);								  		      pcp->curr = &pcp->array[i];
    }											  		      pcp->array[i].matched = *curr;
    pcp->size = pda->productions[index].nnodes;						  		      pcp->array[i].pass = true;
    memset(pcp, 0, sizeof(*pcp) + pda->productions[index].nnodes * sizeof(pnode_s));	  		      result = match(curr, pnode);
    pcp->size = pda->productions[index].nnodes;						  		      if (!result) {
    for(pnode = pda->productions[index].start, i = 0; i < pcp->size; pnode = pnode->next, 			  errsize = sizeof(SYNERR_PREFIX)+FS_INTWIDTH_DEC((*curr)->lineno)
	pcp->array[i].matched = NULL;							  				  + strlen(pnode->token->lexeme)+sizeof(" but got ")+strlen
	pcp->array[i] = *pnode;								  			  synerr = malloc(errsize);
	pcp->array[i].in = in;								  			  if (!synerr) {
    }											  			      perror("Memory Allocation Error");
											  			      exit(EXIT_FAILURE);
    pnode = pda->productions[index].start;						  			  }
    if (pnode->token->type.val == LEXTYPE_EPSILON) {					  			  sprintf(synerr, SYNERR_PREFIX "%s but got %s", (*curr)->lineno, p







2014-02-11 02:00                                                                           parse.c                                                                           Page 10


			synerr[errsize-1] = '\n';					  	  }
			adderror(parse->listing, synerr, (*curr)->lineno);		      }
			success = false;						      if (gotepsilon || LLTOKEN(iter)->type.val == LEXTYPE_EPSILON) {
			if ((*curr)->type.val == LEXTYPE_EOF) {				  	  oldsize = errbuf_check(&errstr, &bsize, &errsize, LLTOKEN(iter)->lexeme);
			    grstack_pop();						  	  sprintf(&errstr[oldsize], "%s ", LLTOKEN(iter)->lexeme);
			    return NULL;						  	  for (iter = pda->follows; iter->next; iter = iter->next) {
			}								  	      oldsize = errbuf_check(&errstr, &bsize, &errsize, LLTOKEN(iter)->lexeme);
			*curr = (*curr)->next;						  	      sprintf(&errstr[oldsize], "%s ", LLTOKEN(iter)->lexeme);
		    }									  	  }
		}									      }
	    }										      oldsize = errsize;
	    while(!success);								      if (iter == start)
	}										  	  errsize += sizeof(" but got: ") + strlen(LLTOKEN(iter)->lexeme) + strlen((*curr)-
    }											      else
    sem_start(NULL, parse, machs, pda, &pda->productions[index], pcp, synhash, ++pass, tr 	  errsize += sizeof("  but got: ") + strlen(LLTOKEN(iter)->lexeme) + strlen((*curr)
    grstack_pop();									      if (errsize > bsize) {
    return synhash;									  	  bsize = errsize;
}											  	  errstr = realloc(errstr, bsize);
											  	  if (!errstr) {
size_t errbuf_check(char **buffer, size_t *bsize, size_t *errsize, char *lexeme)	  	      perror("Memory Allocation Error");
{											  	      exit(EXIT_FAILURE);
    size_t oldsize = *errsize;								  	  }
    *errsize += strlen(lexeme)+2;							      }
    if (*errsize >= *bsize) {								      else if (errsize != bsize){
	*bsize *=2;									  	  errstr = realloc(errstr, errsize);
	*buffer = realloc(*buffer, *bsize);						  	  if (!errstr) {
	if (!*buffer) {									  	      perror("Memory Allocation Error");
	    perror("Memory Allocation Error");						  	      exit(EXIT_FAILURE);
	    exit(EXIT_FAILURE);								  	  }
	}										      }
    }											      sprintf(&errstr[oldsize], "%s but got: %s", LLTOKEN(iter)->lexeme, (*curr)->lexeme);
    return oldsize+1;									  
}											      errstr[errsize-1] = '\n';
											      return errstr;
char *make_synerr(pda_s *pda, token_s **curr)						  }
{											  
    bool gotepsilon = false;								  void panic_recovery(llist_s *follow, token_s **curr)
    size_t errsize, bsize, oldsize;							  {
    llist_s *iter, *start;								      llist_s *iter;
    char *errstr;									  
											      while ((*curr)->type.val != LEXTYPE_EOF) {
    bsize = INIT_SYNERRSIZE;								  	  for (iter = follow; iter; iter = iter->next) {
    errsize = sizeof(SYNERR_PREFIX) + FS_INTWIDTH_DEC((*curr)->lineno);			  	      if (LLTOKEN(iter)->type.val == (*curr)->type.val)
    errstr = calloc(1, INIT_SYNERRSIZE);						  		  return;
    if (!errstr) {									  	  }
	perror("Memory Allocation Error");						  	  *curr = (*curr)->next;
	exit(EXIT_FAILURE);								      }
    }											  }
    sprintf(errstr, SYNERR_PREFIX, (*curr)->lineno);					  
    oldsize = errsize;									  int get_production(parsetable_s *ptable, pda_s *pda, token_s **curr)
    for (start = iter = pda->firsts; iter->next; iter = iter->next) {			  {
	if (LLTOKEN(iter)->type.val == LEXTYPE_EPSILON)					      uint16_t i, j;
	    gotepsilon = true;								  
	else {										      for (i = 0; i < ptable->n_nonterminals; i++) {
	    oldsize = errbuf_check(&errstr, &bsize, &errsize, LLTOKEN(iter)->lexeme);	  	  if (!strcmp(pda->nterm->lexeme, ptable->nterms[i]->lexeme)) {
	    sprintf(&errstr[oldsize], "%s ", LLTOKEN(iter)->lexeme);			  	      for (j = 0; j < ptable->n_terminals; j++) {







2014-02-11 02:00                                                                           parse.c                                                                           Page 11


		//printf("comparing: %s %d to %s %d\n", (*curr)->lexeme, (*curr)->type.va 	  parser->start = pda;
		if ((*curr)->type.val == ptable->terms[j]->type.val) {			      return hashinsert (parser->phash, name, pda);
		    if (ptable->table[i][j] == -1)					  }
			continue;							  
		    return ptable->table[i][j];						  uint16_t str_hashf(void *key)
		}									  {
	    }										      return *(uint64_t *)key % HTABLE_SIZE;
	    return -1;									  }
	}										  
    }											  bool find_in(void *k1, void *k2)
    return -1;										  {
}											      return ((semantics_s *)k1)->n == k2;
											  }
pda_s *get_pda(parse_s *parser, char *name)						  
{											  void print_pnode_hash(void *key, void *data)
    return hashlookup(parser->phash, name);						  {
}											      extern void print_semtype(sem_type_s value);
											  
bool hash_pda(parse_s *parser, char *name, pda_s *pda)					      print_semtype(*(sem_type_s *)data);
{											  }
    if (!parser->start)










































2014-02-08 21:58                                                                         semantics.h                                                                          Page 1


/*											  
 lex.h											  struct pna_s
 Author: Jonathan Hamm									  {
											      int size;
 Description:										      pnode_s *curr;
 Library for semantics analysis.							      pnode_s array[];
											  };
 */											  
											  extern llist_s *grammar_stack;
#ifndef SEMANTICS_H_									  
#define SEMANTICS_H_									  extern inline void grstack_push(void);
											  extern inline void grstack_pop(void);
#include "general.h"									  
#include <stdint.h>									  extern semantics_s *semantics_s_(parse_s *parse, mach_s *machs);
											  extern void free_sem(semantics_s *s);
typedef struct semantics_s semantics_s;							  
typedef struct pna_s pna_s;								  extern lex_s *semant_init(void);
											  extern uint32_t cfg_annotate(token_s **tlist, char *buf, uint32_t *lineno, void *data);
struct semantics_s									  extern llist_s *sem_start(semantics_s *in, parse_s *parse, mach_s *machs, pda_s *pda, pro
{											  
    pnode_s *n;										  extern semantics_s *get_il(llist_s *l, pnode_s *p);
    parse_s *parse;									  
    mach_s *machs;									  extern void write_code(void);
    hash_s *table;									  
};											  #endif






































2014-02-11 11:32                                                                         semantics.c                                                                          Page 1


/*											      SEMTYPE_THEN,
 semantics.c										      SEMTYPE_ELSE,
 Author: Jonathan Hamm									      SEMTYPE_END,
											      SEMTYPE_NOT,
 Description:										      SEMTYPE_OPENPAREN,
 Implementation of semantics analysis.							      SEMTYPE_CLOSEPAREN,
											      SEMTYPE_DOT,
*/											      SEMTYPE_COMMA,
											      SEMTYPE_SEMICOLON,
#include "lex.h"									      SEMTYPE_OPENBRACKET,
#include "parse.h"									      SEMTYPE_CLOSEBRACKET,
#include "semantics.h"									      SEMTYPE_ELIF,
#include <stdio.h>									      /* When removing one of these, subtract 1 from MACHID_START */
#include <stdlib.h>									  
#include <math.h>									      /*gap for id types*/
											      SEMTYPE_ID = MACHID_START,
#define REGEX_DECORATIONS_FILE "regex_decorations"					      SEMTYPE_NONTERM,
#define MACHID_START		37							      SEMTYPE_NUM,
											      SEMTYPE_RELOP,
#define SEMSIGN_POS 0									      SEMTYPE_ASSIGNOP,
#define SEMSIGN_NEG 1									      SEMTYPE_CROSS,
											      SEMTYPE_ADDOP,
#define OPTYPE_NOP  -1									      SEMTYPE_MULOP,
#define OPTYPE_MULT 0									      SEMTYPE_CODE,
#define OPTYPE_DIV  1									      SEMTYPE_CONCAT,
#define OPTYPE_ADD  2									      SEMTYPE_MAP,
#define OPTYPE_SUB  3									  };
#define OPTYPE_L    4									  
#define OPTYPE_G    5									  typedef struct att_s att_s;
#define OPTYPE_LE   6									  
#define OPTYPE_GE   7									  /* Return Structures */
#define OPTYPE_EQ   8									  typedef struct access_s access_s;
#define OPTYPE_NE   9									  typedef struct sem_statements_s sem_statements_s;
#define OPTYPE_OR   10									  typedef struct sem_statement_s sem_statement_s;
#define OPTYPE_AND  11									  typedef struct sem_else_s sem_else_s;
											  typedef struct sem_elif_s sem_elif_s;
#define ATTYPE_MULT 0									  typedef struct sem_elif__s sem_elif__s;
#define ATTYPE_DIV  1									  typedef struct sem_expression_s sem_expression_s;
#define ATTYPE_AND  2									  typedef struct sem_expression__s sem_expression__s;
#define ATTYPE_ADD  0									  typedef struct sem_simple_expression_s sem_simple_expression_s;
#define ATTYPE_SUB  1									  typedef struct sem_simple_expression__s sem_simple_expression__s;
#define ATTYPE_OR   2									  typedef struct sem_term_s sem_term_s;
#define ATTYPE_EQ   0									  typedef struct sem_term__s sem_term__s;
#define ATTYPE_NE   1									  typedef struct sem_factor_s sem_factor_s;
#define ATTYPE_L    2									  typedef struct sem_factor__s sem_factor__s;
#define ATTYPE_LE   3									  typedef struct sem_idsuffix_s sem_idsuffix_s;
#define ATTYPE_GE   4									  typedef struct sem_dot_s sem_dot_s;
#define ATTYPE_G    5									  typedef struct sem_range_s sem_range_s;
											  typedef struct sem_paramlist_s sem_paramlist_s;
#define TYPE_ERROR_PREFIX "	 --Semantics Error at line %u: "			  typedef struct sem_paramlist__s sem_paramlist__s;
#define TYPE_ERROR_SUFFIX " at token %s"						  typedef struct sem_sign_s sem_sign_s;
											  typedef struct ftable_s ftable_s;
#define FTABLE_SIZE (sizeof(ftable) / sizeof(ftable[0]))				  typedef struct test_s test_s;
											  
enum semantic_types_ {									  typedef void *(*sem_action_f)(token_s **, semantics_s *, pda_s *, pna_s *, parse_s *, sem
    SEMTYPE_IF = LEXID_START+1, //Guarantees that lexical and semantics token types are d 







2014-02-11 11:32                                                                         semantics.c                                                                          Page 2


struct access_s										      sem_type_s value;
{											  };
    char *base;										  
    long offset;									  struct sem_term__s
    char *attribute;									  {
};											      unsigned op;
											      sem_type_s value;
struct sem_statements_s									  };
{											  
											  struct sem_factor_s
};											  {
											      sem_type_s value;
struct sem_statement_s									      access_s access;
{											  };
											  
};											  struct sem_factor__s
											  {
struct sem_else_s									      bool isset;
{											      unsigned index;
											  };
};											  
											  struct sem_range_s
struct sem_elif_s									  {
{											      bool isready;
											      bool isset;
};											      long value;
											  };
struct sem_elif__s									  
{											  struct sem_dot_s
											  {
};											      sem_range_s range;
											      char *id;
struct sem_expression_s									  };
{											  
    sem_type_s value;									  struct sem_paramlist_s
};											  {
											      bool ready;
struct sem_expression__s								      llist_s *pstack;
{											  };
    unsigned op;									  
    sem_type_s value;									  struct sem_paramlist__s
};											  {
											      llist_s *pstack;
struct sem_simple_expression_s								  };
{											  
    sem_type_s value;									  struct sem_idsuffix_s
};											  {
											      sem_factor__s factor_;
struct sem_simple_expression__s								      sem_dot_s dot;
{											      bool hasparam;
    unsigned op;									      sem_paramlist_s params;
    sem_type_s value;									      bool hasmap;
};											      sem_type_s map;
											  };
struct sem_term_s									  
{											  struct sem_sign_s







2014-02-11 11:32                                                                         semantics.c                                                                          Page 3


{											  static bool sem_match (token_s **curr, int type);
    long value;										  
};											  static sem_type_s *alloc_semt(sem_type_s value);
											  static att_s *att_s_ (void *data, unsigned tid);
struct att_s										  static void setatt(semantics_s *s, char *id, sem_type_s *data);
{											  static sem_type_s getatt(semantics_s *s, char *id);
    unsigned tid;									  static void *sem_array(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *p
    char *lexeme;									  static void *sem_emit(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *pa
};											  static void *sem_error(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *p
											  static void *sem_getarray(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s
struct ftable_s										  static void *sem_gettype(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s
{											  static void *sem_halt(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *pa
    const char *key;									  static void *sem_lookup(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *
    sem_action_f action;								  static void *sem_print(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *p
};											  static void *sem_addtype(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s
											  static void *sem_addarg(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *
struct test_s										  static void *sem_listappend(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse
{											  static void *sem_makelista(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_
    bool evaluated;									  static void *sem_makelistf(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_
    bool result;									  static void *sem_pushscope(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_
};											  static void *sem_popscope(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s
											  static void *sem_resettemps(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse
FILE *emitdest;										  static void *sem_resolveproc(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, pars
llist_s *grammar_stack;									  static void *sem_getwidth(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s
static unsigned tempcount;								  static void *sem_low(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *par
static unsigned lablecount;								  
											  static int arglist_cmp(token_s **curr, parse_s *parse, token_s *tok, sem_type_s formal, s
static uint16_t semgrammar_hashf(void *key);						  
static bool semgrammar_isequalf(void *key1, void *key2);				  
static sem_type_s sem_type_s_(parse_s *parse, token_s *token);				  static int ftable_strcmp(char *key, ftable_s *b);
static test_s test_semtype(sem_type_s value);						  static sem_action_f get_semaction(char *str);
static inline unsigned toaddop(unsigned val);						  static char *sem_tostring(sem_type_s type);
static inline unsigned tomulop(unsigned val);						  static char *semstr_concat(char *base, sem_type_s val);
static inline unsigned torelop(unsigned val);						  static void set_type(semantics_s *s, char *id, sem_type_s type);
static pnode_s *getpnode_token(pna_s *pn, char *lexeme, unsigned index);		  static sem_type_s get_type(semantics_s *s, char *id);
static pnode_s *getpnode_nterm_copy(pna_s *pn, char *lexeme, unsigned index);		  static char *make_semerror(unsigned lineno, char *lexeme, char *message);
static pnode_s *getpnode_nterm(production_s *prod, char *lexeme, unsigned index);	  static void add_semerror(parse_s *p, token_s *t, char *message);
static sem_type_s sem_op(token_s **curr, parse_s *parse, token_s *tok, sem_type_s v1, sem 
static sem_statements_s sem_statements (parse_s *parse, token_s **curr, llist_s **il, pda static sem_type_s sem_newtemp(token_s **curr);
static sem_statement_s sem_statement (parse_s *parse, token_s **curr, llist_s **il, pda_s static sem_type_s sem_newlabel(token_s **curr);
static sem_else_s sem_else (parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, pro static char *scoped_label(void);
static sem_elif_s sem_elif(parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, prod 
static sem_expression_s sem_expression (parse_s *parse, token_s **curr, llist_s **il,  pd static void write_code_(scope_s *s);
static sem_expression__s sem_expression_ (parse_s *parse, token_s **curr, llist_s **il, p 
static sem_simple_expression_s sem_simple_expression (parse_s *parse, token_s **curr, lli extern void print_semtype(sem_type_s value);
static sem_simple_expression__s sem_simple_expression_ (parse_s *parse, token_s **curr, l 
static sem_term_s sem_term (parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, pro /* Must be alphabetized */
static sem_term__s sem_term_ (parse_s *parse, token_s **curr, llist_s **il, sem_type_s *a static ftable_s ftable[] = {
static sem_factor_s sem_factor (parse_s *parse, token_s **curr, llist_s **il, pda_s *pda,     {"addarg", (sem_action_f)sem_addarg},
static sem_factor__s sem_factor_ (parse_s *parse, token_s **curr, llist_s **il, pna_s *pn     {"addtype", (sem_action_f)sem_addtype},
static sem_idsuffix_s sem_idsuffix (parse_s *parse, token_s **curr, llist_s **il, pda_s *     {"array", (sem_action_f)sem_array},
static sem_dot_s sem_dot (parse_s *parse, token_s **curr, llist_s **il, pna_s *pn, semant     {"emit", sem_emit},
static sem_range_s sem_range (parse_s *parse, token_s **curr, llist_s **il, pna_s *pn, se     {"error", sem_error},
static sem_paramlist_s sem_paramlist (parse_s *parse, token_s **curr, llist_s **il, pda_s     {"getarray", sem_getarray},
static void sem_paramlist_ (parse_s *parse, token_s **curr, llist_s **il, sem_paramlist_s     {"gettype", sem_gettype},
static sem_sign_s sem_sign (token_s **curr);						      {"halt", sem_halt},







2014-02-11 11:32                                                                         semantics.c                                                                          Page 4


    {"listappend", (sem_action_f)sem_listappend},					  		      case LEXATTR_PLUS:
    {"lookup", sem_lookup},								  			  s.str_ = "+";
    {"low", (sem_action_f)sem_low},							  			  break;
    {"makelista", (sem_action_f)sem_makelista},						  		      case LEXATTR_MINUS:
    {"makelistf", (sem_action_f)sem_makelistf},						  			  s.str_ = "-";
    {"popscope", (sem_action_f)sem_popscope},						  			  break;
    {"print", sem_print},								  		      case LEXATTR_OR:
    {"pushscope", (sem_action_f)sem_pushscope},						  			  s.str_ = "OR";
    {"resettemps", (sem_action_f)sem_resettemps},					  			  break;
    {"resolveproc", (sem_action_f)sem_resolveproc},					  		      default:
    {"width", (sem_action_f)sem_getwidth},						  			  assert(false);
};											  			  break;
											  		  }
inline void grstack_push(void)								  	      }
{											  	      else if((match = lex_matches(parse->lex, "mulop", token->lexeme)).matched) {
    hash_s *h = hash_(semgrammar_hashf, semgrammar_isequalf);				  		  switch(match.attribute){
    llpush(&grammar_stack, h);								  		      case LEXATTR_MULT:
}											  			  s.str_ = "*";
											  			  break;
inline void grstack_pop(void)								  		      case LEXATTR_DIV1:
{											  		      case LEXATTR_DIV2:
    llist_s *l = llpop(&grammar_stack);							  			  s.str_ = "/";
    free_hash(l->ptr);									  			  break;
    free(l);										  		      case LEXATTR_MOD:
}											  			  s.str_ = "MOD";
											  			  break;
uint16_t semgrammar_hashf(void *key)							  		      case LEXATTR_AND:
{											  			  s.str_ = "AND";
    return (uint16_t)((intptr_t)key % HTABLE_SIZE);					  			  break;
}											  		      default:
											  			  assert(false);
bool semgrammar_isequalf(void *key1, void *key2)					  			  break;
{											  		  }
    return key1 == key2;								  	      }
}											  	      else if((match = lex_matches(parse->lex, "relop", token->lexeme)).matched) {
											  		  switch(match.attribute) {
sem_type_s sem_type_s_(parse_s *parse, token_s *token)					  		      case LEXATTR_EQ:
{											  			  s.str_ = "=";
    sem_type_s s;									  			  break;
    tlookup_s res;									  		      case LEXATTR_NEQ:
    regex_match_s match;								  			  s.str_ = "<>";
											  			  break;
											  		      case LEXATTR_LE:
    s.str_ = NULL;									  			  s.str_ = "<";
    s.low = 0 ;										  			  break;
    s.high = 0;										  		      case LEXATTR_LEQ:
    if(!token->stype) {									  			  s.str_ = "<=";
	res = idtable_lookup(parse->lex->idtable, token->lexeme);			  			  break;
	if(res.is_found) {								  		      case LEXATTR_GEQ:
	    s = res.tdat.type;								  			  s.str_ = ">=";
	    s.str_ = token->lexeme;							  			  break;
	}										  		      case LEXATTR_GE:
	else {										  			  s.str_ = ">";
	    s.type = ATTYPE_CODE;							  			  break;
	    if((match = lex_matches(parse->lex, "addop", token->lexeme)).matched) {	  		      default:
		switch(match.attribute){						  			  assert(false);







2014-02-11 11:32                                                                         semantics.c                                                                          Page 5


			break;								  	  case ATTYPE_VOID:
		}									  	      printf("void");
	    }										  	      break;
	    else if (!strcmp(token->lexeme, "integer")) {				  	  case ATTYPE_NOT_EVALUATED:
		s.type = ATTYPE_ID;							  	      printf("not evaluated");
		s.str_ = "integer";							  	      break;
	    }										  	  case ATTYPE_ARGLIST_FORMAL:
	    else if (!strcmp(token->lexeme, "real")) {					  	  case ATTYPE_ARGLIST_ACTUAL:
		s.type = ATTYPE_ID;							  	      printf("arg list");
		s.str_ = "real";							  	      break;
	    }										  	  default:
	    else {									  	      puts("ILLEGAL STATE");
		s.type = ATTYPE_ID;							  	      assert(false);
		s.str_ = token->lexeme;							  	      /*illegal*/
	    }										  	      break;
	}										      }
    }											  }
    else if(!strcmp(token->stype, "integer")) {						  
	s.type = ATTYPE_ID;								  test_s test_semtype(sem_type_s value)
	s.str_ = "integer";								  {
    }											      if(value.type == ATTYPE_NOT_EVALUATED || value.type == ATTYPE_NULL)
    else if(!strcmp(token->stype, "real")) {						  	  return (test_s){.evaluated = false, .result = false};
	s.type = ATTYPE_ID;								      return (test_s){.evaluated = true, .result = value.int_ || value.real_ || value.str_}
	s.str_ = "real";								  }
    }											  
    else {										  semantics_s *semantics_s_(parse_s *parse, mach_s *machs)
	s.type = ATTYPE_ID;								  {
	s.str_ = token->lexeme;								      semantics_s *s;
    }											  
    return s;										      s = malloc(sizeof(*s));
}											      if (!s) {
											  	  perror("Memory Allocation Error");
void print_semtype(sem_type_s value)							  	  exit(EXIT_FAILURE);
{											      }
    switch (value.type) {								      s->parse = parse;
	case ATTYPE_NUMINT:								      s->machs = machs;
	    printf("%ld", value.int_);							      s->table = hash_(pjw_hashf, str_isequalf);
	    break;									      return s;
	case ATTYPE_NUMREAL:								  }
	    printf("%f", value.real_);							  
	    break;									  lex_s *semant_init(void)
	case ATTYPE_ID:									  {
	case ATTYPE_CODE:								      return buildlex(REGEX_DECORATIONS_FILE);
	case ATTYPE_TEMP:								  }
	case ATTYPE_LABEL:								  
	    printf("%s", value.str_);							  uint32_t cfg_annotate (token_s **tlist, char *buf, uint32_t *lineno, void *data)
	    break;									  {
	case ATTYPE_RANGE:								      uint32_t i;
	    printf("%ld..%ld", value.low, value.high);					      lextok_s ltok;
	    break;									      static unsigned anlineno = 0;
	case ATTYPE_ARRAY:								      static unsigned last;
	    printf("array[%ld..%ld] of type %s", value.low, value.high, value.lexeme);	  
	    break;									      assert(*lineno < 500);
	case ATTYPE_NULL:								      for (i = 1; buf[i] != '}'; i++);
	    printf("null");								      buf[i] = EOF;
	    break;									  







2014-02-11 11:32                                                                         semantics.c                                                                          Page 6


    addtok(tlist, "generated {", *lineno, LEXTYPE_ANNOTATE, LEXATTR_DEFAULT, NULL);	  }
    ltok = lexf(data, &buf[1], anlineno, true);						  
    anlineno = ltok.lines;								  pnode_s *getpnode_token(pna_s *pn, char *lexeme, unsigned index)
    *lineno = ltok.lines;								  {
    (*tlist)->next = ltok.tokens;							      unsigned i, j;
    ltok.tokens->prev = *tlist;								  
    while ((*tlist)->next)								      for (i = 0, j = 1; i < pn->size; i++) {
	*tlist = (*tlist)->next;							  	  if (!strcmp(pn->array[i].token->lexeme, lexeme)) {
    last = *lineno;									  	      if (j == index)
    return i;										  		  return &pn->array[i];
}											  	      j++;
											  	  }
unsigned toaddop(unsigned val)								      }
{											      return NULL;
    if (val == ATTYPE_ADD)								  }
	return OPTYPE_ADD;								  
    if (val == ATTYPE_SUB)								  pnode_s *getpnode_nterm_copy(pna_s *pn, char *lexeme, unsigned index)
	return OPTYPE_SUB;								  {
    if (val == ATTYPE_OR)								      unsigned i, j;
	return OPTYPE_OR;								  
    perror("Op attribute mismatch");							      for (i = 0, j = 1; i < pn->size; i++) {
    assert(false);									  	  if (!strcmp(pn->array[i].token->lexeme, lexeme)) {
}											  	      if (j == index)
											  		  return &pn->array[i];
unsigned tomulop(unsigned val)								  	      i++;
{											  	  }
    if (val == ATTYPE_MULT)								      }
	return OPTYPE_MULT;								      return NULL;
    if (val == ATTYPE_DIV)								  }
	return OPTYPE_DIV;								  
    if (val == ATTYPE_AND)								  pnode_s *getpnode_nterm(production_s *prod, char *lexeme, unsigned index)
	return OPTYPE_AND;								  {
    perror("Op attribute mismatch");							      unsigned j;
    assert(false);									      pnode_s *p;
}											  
											      for(p = prod->start, j = 1; p; p = p->next) {
unsigned torelop(unsigned val)								  	  if(!strcmp(p->token->lexeme, lexeme)) {
{											  	      if(j == index)
    switch(val) {									  		  return p;
	case ATTYPE_EQ:									  	      j++;
	    return OPTYPE_EQ;								  	  }
	case ATTYPE_NE:									      }
	    return OPTYPE_NE;								      return NULL;
	case ATTYPE_L:									  }
	    return OPTYPE_L;								  
	case ATTYPE_LE:									  /* performs basic arithmetic operations with implicit type coercion */
	    return OPTYPE_LE;								  sem_type_s sem_op(token_s **curr, parse_s *parse, token_s *tok, sem_type_s v1, sem_type_s
	case ATTYPE_GE:									  {
	    return OPTYPE_GE;								      sem_type_s result;
	case ATTYPE_G:									      result.str_ = NULL;
	    return OPTYPE_G;								      if(op != OPTYPE_NOP) {
	default:									  	  if(v1.type == ATTYPE_NULL) {
	    perror("Illegal State");							  	      if(op == OPTYPE_EQ) {
	    assert(false);								  		  result.type = ATTYPE_NUMINT;
	    break;									  		  result.int_ = ((v2.type == ATTYPE_NOT_EVALUATED) || (v2.type == ATTYPE_NU
    }											  	      }







2014-02-11 11:32                                                                         semantics.c                                                                          Page 7


	    else if(op == OPTYPE_NE) {							  		  fprintf(stderr, "Type Error: String type incompatible with division.\n");
		result.type = ATTYPE_NUMINT;						  	      if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT) {
		result.int_ = !((v2.type == ATTYPE_NOT_EVALUATED) || (v2.type == ATTYPE_N 		  result.type = ATTYPE_NUMREAL;
	    }										  		  result.real_ = v1.int_ / v2.int_;
	    result.tok = tok_lastmatched;						  	      }
	    return result;								  	      else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL) {
	}										  		  result.type = ATTYPE_NUMREAL;
	if(v2.type == ATTYPE_NULL) {							  		  result.real_ = v1.int_ / v2.real_;
	    if(op == OPTYPE_EQ) {							  	      }
		result.type = ATTYPE_NUMINT;						  	      else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT) {
		result.int_ = ((v1.type == ATTYPE_NOT_EVALUATED) || (v1.type == ATTYPE_NU 		  result.type = ATTYPE_NUMREAL;
	    }										  		  result.real_ = v1.real_ / v2.int_;
	    else if(op == OPTYPE_NE) {							  	      }
		result.type = ATTYPE_NUMINT;						  	      else {
		result.int_ = !((v1.type == ATTYPE_NOT_EVALUATED) || (v1.type == ATTYPE_N 		  result.type = ATTYPE_NUMREAL;
	    }										  		  result.real_ = v1.real_ / v2.real_;
	    result.tok = tok_lastmatched;						  	      }
	    return result;								  	      break;
	}										  	  case OPTYPE_ADD:
	if (v1.type == ATTYPE_NOT_EVALUATED || v2.type == ATTYPE_NOT_EVALUATED) {	  	      if (v1.type == ATTYPE_ID || v2.type == ATTYPE_ID)
	    result.type = ATTYPE_NOT_EVALUATED;						  		  fprintf(stderr, "Type Error: Not yet implemented.\n");
	    result.str_ = "null";							  	      if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT) {
	    result.tok = tok_lastmatched;						  		  result.type = ATTYPE_NUMINT;
	    return result;								  		  result.int_ = v1.int_ + v2.int_;
	}										  	      }
	else if(v1.type == ATTYPE_NULL || v2.type == ATTYPE_NULL) {			  	      else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL) {
	    result.type = ATTYPE_NULL;							  		  result.type = ATTYPE_NUMREAL;
	    result.str_ = "null";							  		  result.real_ = v1.int_ + v2.real_;
	    result.tok = tok_lastmatched;						  	      }
	    return result;								  	      else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT) {
	}										  		  result.type = ATTYPE_NUMREAL;
    }											  		  result.real_ = v1.real_ + v2.int_;
    switch(op) {									  	      }
	case OPTYPE_MULT:								  	      else {
	    assert (v1.int_ != 28);							  		  result.type = ATTYPE_NUMREAL;
	    if (v1.type == ATTYPE_ID || v2.type == ATTYPE_ID)				  		  result.real_ = v1.real_ + v2.real_;
		fprintf(stderr, "Type Error: String type incompatible with multiplication 	      }
	    if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT) {			  	      break;
		result.type = ATTYPE_NUMINT;						  	  case OPTYPE_SUB:
		result.int_ = v1.int_ * v2.int_;					  	      if (v1.type == ATTYPE_ID || v2.type == ATTYPE_ID)
	    }										  		  fprintf(stderr, "Type Error: String type incompatible with subtraction.\n
	    else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL) {		  	      if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT) {
		result.type = ATTYPE_NUMREAL;						  		  result.type = ATTYPE_NUMINT;
		result.real_ = v1.int_ * v2.real_;					  		  result.int_ = v1.int_ - v2.int_;
	    }										  	      }
	    else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT) {		  	      else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL) {
		result.type = ATTYPE_NUMREAL;						  		  result.type = ATTYPE_NUMREAL;
		result.real_ = v1.real_ * v2.int_;					  		  result.real_ = v1.int_ - v2.real_;
	    }										  	      }
	    else {									  	      else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT) {
		result.type = ATTYPE_NUMREAL;						  		  result.type = ATTYPE_NUMREAL;
		result.real_ = v1.real_ * v2.real_;					  		  result.real_ = v1.real_ - v2.int_;
	    }										  	      }
	    break;									  	      else {
	case OPTYPE_DIV:								  		  result.type = ATTYPE_NUMREAL;
	    if (v1.type == ATTYPE_ID || v2.type == ATTYPE_ID)				  		  result.real_ = v1.real_ - v2.real_;







2014-02-11 11:32                                                                         semantics.c                                                                          Page 8


	    }										  	      result.int_ = 0;
	    break;									  	      if ((v1.type == ATTYPE_CODE || v1.type == ATTYPE_ID || v1.type == ATTYPE_VOID
	case OPTYPE_L:									  		  result.int_ = !strcmp(v1.str_, v2.str_);
	    if (v1.type == ATTYPE_ID || v2.type == ATTYPE_ID)				  		  if(v1.type != v2.type) {
		fprintf(stderr, "Type Error: String type incompatible with subtraction.\n 		      if(v1.type == ATTYPE_CODE)
	    result.type = ATTYPE_NUMINT;						  			  result.int_ = !quote_strcmp(v1.str_, v2.str_);
	    if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT)			  		      else if (v2.type == ATTYPE_CODE)
		result.int_ = v1.int_ < v2.int_;					  			  result.int_ = !quote_strcmp(v2.str_, v1.str_);
	    else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL)		  		  }
		result.int_ = v1.int_ < v2.real_;					  	      }
	    else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT)		  	      else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT)
		result.int_ = v1.real_ < v2.int_;					  		  result.int_ = v1.int_ == v2.int_;
	    else									  	      else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL)
		result.int_ = v1.real_ < v2.real_;					  		  result.int_ = v1.int_ == v2.real_;
	    break;									  	      else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT)
	case OPTYPE_G:									  		  result.int_ = v1.real_ == v2.int_;
	    if (v1.type == ATTYPE_ID || v2.type == ATTYPE_ID)				  	      else if(v1.type == ATTYPE_ARRAY || v2.type == ATTYPE_ARRAY) {
		fprintf(stderr, "Type Error: String type incompatible with subtraction.\n 		  result.int_ = (v2.type == ATTYPE_ARRAY && v1.low == v2.low && v1.high ==
	    result.type = ATTYPE_NUMINT;						  	      }
	    if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT)			  	      else if((v1.type == ATTYPE_ARGLIST_FORMAL || v1.type == ATTYPE_ARGLIST_ACTUAL
		result.int_ = v1.int_ > v2.int_;					  		  if(v1.type == ATTYPE_ARGLIST_FORMAL)
	    else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL)		  		      result.int_ = arglist_cmp(curr, parse, tok, v1, v2);
		result.int_ = v1.int_ > v2.real_;					  		  else
	    else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT)		  		      result.int_ = arglist_cmp(curr, parse, tok, v2, v1);
		result.int_ = v1.real_ > v2.int_;					  		  result.int_ = 0;
	    else									  	      }
		result.int_ = v1.real_ > v2.real_;					  	      else
	    break;									  		  result.int_ = v1.real_ == v2.real_;
	case OPTYPE_LE:									  	      break;
	    if (v1.type == ATTYPE_ID || v2.type == ATTYPE_ID)				  	  case OPTYPE_NE:
		fprintf(stderr, "Type Error: String type incompatible with subtraction.\n 	      result.type = ATTYPE_NUMINT;
	    result.type = ATTYPE_NUMINT;						  	      result.int_ = 0;
	    if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT)			  	      if ((v1.type == ATTYPE_CODE || v1.type == ATTYPE_ID || v1.type == ATTYPE_VOID
		result.int_ = v1.int_ <= v2.int_;					  		  result.int_ = !!strcmp(v1.str_, v2.str_);
	    else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL)		  		  if(v1.type != v2.type) {
		result.int_ = v1.int_ <= v2.real_;					  		      if(v1.type == ATTYPE_CODE)
	    else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT)		  			  result.int_ = !!quote_strcmp(v1.str_, v2.str_);
		result.int_ = v1.real_ <= v2.int_;					  		      else if (v2.type == ATTYPE_CODE)
	    else									  			  result.int_ = !!quote_strcmp(v2.str_, v1.str_);
		result.int_ = v1.real_ <= v2.real_;					  		  }
	    break;									  	      }
	case OPTYPE_GE:									  	      else if(v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT)
	    if (v1.type == ATTYPE_ID || v2.type == ATTYPE_ID)				  		  result.int_ = v1.int_ != v2.int_;
		fprintf(stderr, "Type Error: String type incompatible with subtraction.\n 	      else if(v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL)
	    result.type = ATTYPE_NUMINT;						  		  result.int_ = v1.int_ != v2.real_;
	    if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT)			  	      else if(v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT)
		result.int_ = v1.int_ >= v2.int_;					  		  result.int_ = v1.real_ != v2.int_;
	    else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL)		  	      else if(v1.type == ATTYPE_ARRAY || v2.type == ATTYPE_ARRAY) {
		result.int_ = v1.int_ >= v2.real_;					  		  result.int_ = !(v2.type == ATTYPE_ARRAY && v1.low == v2.low && v1.high ==
	    else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT)		  	      }
		result.int_ = v1.real_ >= v2.int_;					  	      else
	    else									  		  result.int_ = true;
		result.int_ = v1.real_ >= v2.real_;					  	      break;
	    break;									  	  case OPTYPE_OR:
	case OPTYPE_EQ:									  	      if (v1.type == ATTYPE_ID || v2.type == ATTYPE_ID)
	    result.type = ATTYPE_NUMINT;						  		  fprintf(stderr, "Type Error: String type incompatible with subtraction.\n







2014-02-11 11:32                                                                         semantics.c                                                                          Page 9


	    result.type = ATTYPE_NUMINT;						  	  case SEMTYPE_END:
	    if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT)			  	  case SEMTYPE_ELSE:
		result.int_ = v1.int_ || v2.int_;					  	  case SEMTYPE_ELIF:
	    else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL)		  	  case LEXTYPE_EOF:
		result.int_ = v1.int_ || v2.real_;					  	      break;
	    else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT)		  	  default:
		result.int_ = v1.real_ || v2.int_;					  	      fprintf(stderr, "Syntax Error at line %d: Expected if nonterm fi else or $ bu
	    else									  	      assert(false);
		result.int_ = v1.real_ || v2.real_;					  	      break;
	    break;									      }
	case OPTYPE_AND:								  }
	    if (v1.type == ATTYPE_ID || v2.type == ATTYPE_ID)				  
		fprintf(stderr, "Type Error: String type incompatible with subtraction.\n sem_statement_s sem_statement(parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, p
	    result.type = ATTYPE_NUMINT;						  {
	    if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMINT)			      pnode_s *p;
		result.int_ = v1.int_ && v2.int_;					      char *id, *nterm;
	    else if (v1.type == ATTYPE_NUMINT && v2.type == ATTYPE_NUMREAL)		      unsigned index;
		result.int_ = v1.int_ && v2.real_;					      sem_expression_s expression;
	    else if (v1.type == ATTYPE_NUMREAL && v2.type == ATTYPE_NUMINT)		      sem_idsuffix_s idsuffix;
		result.int_ = v1.real_ && v2.int_;					      sem_paramlist_s params;
	    else									      semantics_s *in = NULL;
		result.int_ = v1.real_ && v2.real_;					      test_s test;
	    break;									      token_s *ct;
	case OPTYPE_NOP:								  
											      switch((*curr)->type.val) {
	    result = v1;								  	  case SEMTYPE_NONTERM:
	    break;									  	      nterm = (*curr)->lexeme;
	default:									  	      *curr = (*curr)->next;
	    perror("Illegal State");							  	      idsuffix = sem_idsuffix(parse, curr, il, pda, prod, pn, syn, pass, evaluate.e
	    assert(false);								  	      index = idsuffix.factor_.index;
	    break;									  	      id = idsuffix.dot.id;
    }											  	      sem_match(curr, SEMTYPE_ASSIGNOP);
    result.tok = tok_lastmatched;							  	      expression = sem_expression(parse, curr, il, pda, prod, pn, syn, pass, evalua
    return result;									  	      if (evaluate.result && evaluate.evaluated && expression.value.type != ATTYPE_
}											  		  if(!strcmp(pda->nterm->lexeme, nterm) && !idsuffix.factor_.isset) {
											  		      if(syn) {
llist_s *sem_start(semantics_s *in, parse_s *parse, mach_s *machs, pda_s *pda, production 			  setatt(syn, id, alloc_semt(expression.value));
{											  		      }
    token_s *iter = prod->annot;							  		  }
    llist_s *ilist = NULL;								  		  else {
											  		      /* Setting inherited attributes */
    if(!iter)										  		      p = getpnode_nterm(prod, nterm, index);
	return NULL;									  		      if(p && expression.value.type != ATTYPE_NOT_EVALUATED) {
											  			  in = get_il(*il, p);
    sem_statements(parse, &iter, &ilist, pda, prod, pn, syn, pass, (test_s){true, true},  			  if(!in) {
    return ilist;									  			      in = semantics_s_(NULL, NULL);
}											  			      in->n = p;
											  			      llpush(il, in);
sem_statements_s sem_statements(parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, 			  }
{											  			  setatt(in, id, alloc_semt(expression.value));
    switch((*curr)->type.val) {								  		      }
	case SEMTYPE_IF:								  		  }
	case SEMTYPE_NONTERM:								  	      }
	case SEMTYPE_ID:								  	      break;
	    sem_statement(parse, curr, il, pda, prod, pn, syn, pass, evaluate, false, isf 	  case SEMTYPE_IF:
	    sem_statements(parse, curr, il, pda, prod, pn, syn, pass, evaluate, false, is 	      ct = *curr;







2014-02-11 11:32                                                                         semantics.c                                                                         Page 10


	    *curr = (*curr)->next;							      sem_else(parse, curr, il, pda, prod, pn, syn, pass, (test_s){.evaluated = test.evalua
	    expression = sem_expression(parse, curr, il, pda, prod, pn, syn, pass, evalua }
	    sem_match(curr, SEMTYPE_THEN);						  
	    test = test_semtype(expression.value);					  sem_expression_s sem_expression(parse_s *parse, token_s **curr, llist_s **il, pda_s *pda,
	    sem_statements(parse, curr, il, pda, prod, pn, syn, pass, (test_s){.evaluated {
	    evaluate.evaluated = evaluate.evaluated;					      sem_expression_s expression;
	    sem_else(parse, curr, il, pda, prod, pn, syn, pass, evaluate, test.result, is     sem_expression__s expression_;
	    break;									      sem_simple_expression_s simple_expression;
	case SEMTYPE_ID:								  
	    id = (*curr)->lexeme;							      expression.value.str_= NULL;
	    *curr = (*curr)->next;							      expression.value.str_ = NULL;
	    sem_match(curr, SEMTYPE_OPENPAREN);						      expression.value.tok = NULL;
	    params = sem_paramlist(parse, curr, il, pda, prod, pn, syn, pass, evaluate.ev     simple_expression.value.str_ = NULL;
	    sem_match(curr, SEMTYPE_CLOSEPAREN);					      simple_expression.value.tok = NULL;
	    if (evaluate.result && evaluate.evaluated && params.ready) {		      simple_expression = sem_simple_expression(parse, curr, il, pda, prod, pn, syn, pass,
		get_semaction(id)(curr, NULL, pda, pn, parse, params, pass, &expression,      expression_ = sem_expression_(parse, curr, il, pda, prod, pn, syn, pass, eval, isfina
	    }										      expression.value = sem_op(curr, parse, tok_lastmatched, simple_expression.value, expr
	    break;									  
	default:									      if(!expression.value.tok) {
	    fprintf(stderr, "Syntax Error at line %d: Expected nonterm or if but got %s", 	  expression.value.tok = expression_.value.tok;
	    assert(false);								  	  if(!expression.value.tok)
	    break;									  	      expression.value.tok = simple_expression.value.tok;
    }											      }
}											      while(!expression.value.tok);
											      return expression;
sem_else_s sem_else(parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, production_ }
{											  
    switch((*curr)->type.val) {								  sem_expression__s sem_expression_(parse_s *parse, token_s **curr, llist_s **il, pda_s *pd
	case SEMTYPE_ELSE:								  {
	    *curr = (*curr)->next;							      sem_expression__s expression_;
	    sem_statements(parse, curr, il, pda, prod, pn, syn, pass, (test_s){.evaluated 
	    sem_match(curr, SEMTYPE_END);						      expression_.value.tok = NULL;
	    break;									      expression_.value.str_ = NULL;
	case SEMTYPE_END:								      switch((*curr)->type.val) {
	    *curr = (*curr)->next;							  	  case SEMTYPE_RELOP:
	    break;									  	      expression_.op = torelop((*curr)->type.attribute);
	case SEMTYPE_ELIF:								  	      *curr = (*curr)->next;
	    sem_elif(parse, curr, il, pda, prod, pn, syn, pass, evaluate, elprev, isfinal 	      expression_.value = sem_simple_expression(parse, curr, il, pda, prod, pn, syn
	    break;									  	      break;
	default:									  	  case SEMTYPE_COMMA:
	    fprintf(stderr, "Syntax Error at line %d: Expected else or fi but got %s\n",  	  case SEMTYPE_END:
	    assert(false);								  	  case SEMTYPE_ELSE:
	    break;									  	  case SEMTYPE_THEN:
    }											  	  case SEMTYPE_IF:
}											  	  case SEMTYPE_NONTERM:
											  	  case SEMTYPE_CLOSEPAREN:
sem_elif_s sem_elif(parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, production_ 	  case SEMTYPE_CLOSEBRACKET:
{											  	  case SEMTYPE_ID:
    test_s test;									  	  case SEMTYPE_ELIF:
    sem_expression_s expression;							  	  case LEXTYPE_EOF:
											  	      expression_.op = OPTYPE_NOP;
    sem_match(curr, SEMTYPE_ELIF);							  	      expression_.value.type = ATTYPE_VOID;
    expression = sem_expression(parse, curr, il, pda, prod, pn, syn, pass, evaluate.evalu 	      break;
    sem_match(curr, SEMTYPE_THEN);							  	  default:
    test = test_semtype(expression.value);						  	      fprintf(stderr, "Syntax Error at line %d: Expected relop ] fi else then if no
    sem_statements(parse, curr, il, pda, prod, pn, syn, pass, (test_s){.evaluated = test. 	      assert(false);







2014-02-11 11:32                                                                         semantics.c                                                                         Page 11


	    break;									      sem_simple_expression__s simple_expression_, simple_expression__;
											  
    }											      term.value.str_ = NULL;
    return expression_;									      term.value.tok = NULL;
}											      simple_expression_.value.str_ = NULL;
											      simple_expression_.value.tok = NULL;
sem_simple_expression_s sem_simple_expression(parse_s *parse, token_s **curr, llist_s **i     simple_expression__.value.str_ = NULL;
{											      simple_expression__.value.tok = NULL;
    sem_sign_s sign;									      switch((*curr)->type.val) {
    sem_simple_expression_s simple_expression;						  	  case SEMTYPE_ADDOP:
    sem_term_s term;									  	      op = toaddop((*curr)->type.attribute);
    sem_simple_expression__s simple_expression_;					  	      *curr = (*curr)->next;
											  	      term = sem_term(parse, curr, il, pda, prod, pn, syn, pass, eval, isfinal);
    simple_expression.value.str_ = NULL;						  	      *accum = sem_op(curr, parse, tok_lastmatched, *accum, term.value, op);
    simple_expression.value.tok = NULL;							  	      simple_expression__ = sem_simple_expression_(parse, curr, il, accum, pda, pro
    term.value.str_ = NULL;								  	      if(!simple_expression_.value.tok) {
    term.value.tok = NULL;								  		  simple_expression_.value.tok = simple_expression__.value.tok;
    simple_expression_.value.str_ = NULL;						  		  if(!simple_expression_.value.tok)
    simple_expression_.value.tok = NULL;						  		      simple_expression_.value.tok = term.value.tok;
    switch((*curr)->type.val) {								  	      }
	case SEMTYPE_ADDOP:								  	      break;
	    sign = sem_sign(curr);							  	  case SEMTYPE_COMMA:
	    simple_expression = sem_simple_expression(parse, curr, il, pda, prod, pn, syn 	  case SEMTYPE_RELOP:
	    if (sign.value == SEMSIGN_NEG) {						  	  case SEMTYPE_END:
		if(simple_expression.value.type == ATTYPE_NUMINT)			  	  case SEMTYPE_ELSE:
		    simple_expression.value.int_ = -simple_expression.value.int_;	  	  case SEMTYPE_THEN:
		else if(simple_expression.value.type == ATTYPE_NUMREAL)			  	  case SEMTYPE_IF:
		    simple_expression.value.real_ = -simple_expression.value.real_;	  	  case SEMTYPE_NONTERM:
		else if(simple_expression.value.type != ATTYPE_NOT_EVALUATED)		  	  case SEMTYPE_CLOSEPAREN:
		    fprintf(stderr, "Type Error: Cannot negate id types\n");		  	  case SEMTYPE_CLOSEBRACKET:
	    }										  	  case SEMTYPE_ID:
	    break;									  	  case SEMTYPE_ELIF:
	case SEMTYPE_NOT:								  	  case LEXTYPE_EOF:
	case SEMTYPE_NUM:								  	      simple_expression_.op = OPTYPE_NOP;
	case SEMTYPE_ID:								  	      simple_expression_.value.type = ATTYPE_VOID;
	case SEMTYPE_NONTERM:								  	      break;
	case SEMTYPE_OPENPAREN:								  	  default:
	case SEMTYPE_CODE:								  	      fprintf(stderr, "Syntax Error at line %d: Expected + - ] = < > <> <= >= fi el
	    term = sem_term(parse, curr, il, pda, prod, pn, syn, pass, eval, isfinal);	  	      assert(false);
	    simple_expression_ = sem_simple_expression_(parse, curr, il, &term.value, pda 	      break;
	    simple_expression.value = term.value;					      }
	    if(!simple_expression.value.tok)						      return simple_expression_;
		simple_expression.value.tok = simple_expression_.value.tok;		  }
	    break;									  
	default:									  sem_term_s sem_term(parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, production_
	    fprintf(stderr, "Syntax Error at line %d: Expected + - not number or identifi {
	    assert(false);								      sem_term_s term;
	    break;									      sem_factor_s factor;
    }											      sem_term__s term_;
    return simple_expression;								  
}											      term.value.str_ = NULL;
											      term.value.tok = NULL;
sem_simple_expression__s sem_simple_expression_(parse_s *parse, token_s **curr, llist_s *     factor.value.str_= NULL;
{											      factor.value.tok = NULL;
    unsigned op;									      term_.value.str_ = NULL;
    sem_term_s term;									      term_.value.tok = NULL;







2014-02-11 11:32                                                                         semantics.c                                                                         Page 12


    factor = sem_factor(parse, curr, il, pda, prod, pn, syn, pass, eval, isfinal);	  
    term_ = sem_term_(parse, curr, il, &factor.value, pda, prod, pn, syn, pass, eval, isf sem_factor_s sem_factor(parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, product
    term.value = factor.value;								  {
    if(!term.value.tok)									      long difference;
	term.value.tok = term_.value.tok;						      token_s *id;
    return term;									      pnode_s *pnode, *ptmp;
}											      semantics_s *in;
											      sem_type_s value;
sem_term__s sem_term_(parse_s *parse, token_s **curr, llist_s **il, sem_type_s *accum, pd     sem_factor_s factor = {0};
{											      sem_idsuffix_s idsuffix;
    unsigned op;									      sem_expression_s expression;
    sem_factor_s factor;								  
    sem_term__s term_, term__;								      factor.value.tok = NULL;
											      expression.value.str_ = NULL;
    factor.value.str_ = NULL;								      value.str_ = NULL;
    term_.value.str_ = NULL;								      switch((*curr)->type.val) {
    term__.value.str_ = NULL;								  	  case SEMTYPE_ID:
    term_.value.tok = NULL;								  	      id = *curr;
    term__.value.tok = NULL;								  	      *curr = (*curr)->next;
    switch((*curr)->type.val) {								  	      idsuffix = sem_idsuffix(parse, curr, il, pda, prod, pn, syn, pass, eval, isfi
	case SEMTYPE_MULOP:								  	      //attadd (semantics_s *s, char *id, sem_type_s *data)
	    op = tomulop((*curr)->type.attribute);					  	      if (idsuffix.dot.id) {
	    *curr = (*curr)->next;							  		  if (!strcmp(idsuffix.dot.id, "entry")) {
	    factor = sem_factor(parse, curr, il, pda, prod, pn, syn, pass, eval, isfinal) 		      pnode = getpnode_token(pn, id->lexeme, idsuffix.factor_.index);
	    *accum = sem_op(curr, parse, tok_lastmatched, *accum, factor.value, op);	  		      if(pnode && pnode->pass) {
	    term_ = sem_term_(parse, curr, il, accum, pda, prod, pn, syn, pass, eval, isf 			  factor.value.str_ = pnode->matched->lexeme;
	    if(!term_.value.tok) {							  			  factor.value.lexeme = pnode->matched->lexeme;
		term_.value.tok = factor.value.tok;					  			  factor.value.type = ATTYPE_ID;
		if(!term_.value.tok)							  			  factor.value.tok = pnode->matched;
		    term_.value.tok = accum->tok;					  		      }
	    }										  		      if (idsuffix.dot.range.isset && idsuffix.dot.range.isready) {
	    break;									  			  factor.value.type = ATTYPE_RANGE;
	case SEMTYPE_COMMA:								  			  pnode = getpnode_token(pn, id->lexeme, idsuffix.factor_.index);
	case SEMTYPE_ADDOP:								  			  if(pnode && pnode->pass) {
	case SEMTYPE_RELOP:								  			      factor.value.low = safe_atol(pnode->matched->lexeme);
	case SEMTYPE_END:								  			      factor.value.high = idsuffix.dot.range.value;
	case SEMTYPE_ELSE:								  			      factor.value.tok = pnode->matched;
	case SEMTYPE_THEN:								  			      difference = factor.value.high - factor.value.low;
	case SEMTYPE_IF:								  			      if(difference < 0)
	case SEMTYPE_NONTERM:								  				  add_semerror(parse, pnode->matched, "Invalid array range.
	case SEMTYPE_CLOSEPAREN:							  			  }
	case SEMTYPE_CLOSEBRACKET:							  		      }
	case SEMTYPE_ID:								  
	case SEMTYPE_ELIF:								  		  }
	case LEXTYPE_EOF:								  		  else if (!strcmp(idsuffix.dot.id, "val")) {
	    term_.op = OPTYPE_NOP;							  		      pnode = getpnode_token(pn, id->lexeme, idsuffix.factor_.index);
	    term_.value.type = ATTYPE_VOID;						  		      if (idsuffix.dot.range.isset && idsuffix.dot.range.isready) {
	    term_.value.str_ = "null";							  			  factor.value.type = ATTYPE_RANGE;
	    break;									  			  pnode = getpnode_token(pn, id->lexeme, idsuffix.factor_.index);
	default:									  			  if(pnode && pnode->pass) {
	    fprintf(stderr, "Syntax Error at line %d: Expected * / ] + - = < > <> <= >= f 			      factor.value.low = safe_atol(pnode->matched->lexeme);
	    assert(false);								  			      factor.value.high = idsuffix.dot.range.value;
	    break;									  			      factor.value.tok = pnode->matched;
    }											  			      difference = factor.value.high - factor.value.low;
    return term_;									  			      if(difference < 0)
}											  				  add_semerror(parse, pnode->matched, "Invalid array range.







2014-02-11 11:32                                                                         semantics.c                                                                         Page 13


			}								  		      factor.value.type = ATTYPE_ID;
		    }									  		  }
		    else {								  		  factor.value.tok = tok_lastmatched;
			if(pnode->matched->stype) {					  	      }
			    if(!strcmp(pnode->matched->stype, "integer")) {		  	      break;
				factor.value.type = ATTYPE_NUMINT;			  	  case SEMTYPE_NONTERM:
				factor.value.int_ = safe_atol(pnode->matched->lexeme);	  	      factor.value.type = ATTYPE_ID;
			    }								  	      factor.value.str_ = (*curr)->lexeme;
			    else if(!strcmp(pnode->matched->stype, "real")) {		  	      factor.access.base = (*curr)->lexeme;
				factor.value.type = ATTYPE_NUMREAL;			  	      *curr = (*curr)->next;
				factor.value.real_ = safe_atod(pnode->matched->lexeme);	  	      idsuffix = sem_idsuffix(parse, curr, il, pda, prod, pn, syn, pass, eval, isfi
			    }								  	      factor.access.offset = idsuffix.factor_.index;
			    factor.value.tok = pnode->matched;				  	      factor.access.attribute = idsuffix.dot.id;
			}								  	      if (idsuffix.dot.id) {
		    }									  		  if (!strcmp(factor.value.str_, pda->nterm->lexeme) && !idsuffix.factor_.i
											  		      if(pn->curr) {
											  			  factor.value = getatt(syn, idsuffix.dot.id);
		}									  
		else if(!strcmp(idsuffix.dot.id, "type")) {				  			  if(factor.value.type == ATTYPE_NOT_EVALUATED) {
		    ptmp = getpnode_token(pn, id->lexeme, 1);				  			      factor.value = getatt(pn->curr->in, idsuffix.dot.id);
		    factor.value = sem_type_s_(parse, ptmp->matched);			  			      if(factor.value.type == ATTYPE_NOT_EVALUATED) {
		    factor.value.tok = ptmp->matched;					  				  factor.value = getatt(pn->curr->syn, idsuffix.dot.id);
		}									  
		else {									  			      }
		    factor.value.str_ = id->lexeme;					  			  }
		    factor.value.lexeme = id->lexeme;					  			  if(!factor.value.tok)
		    factor.value.type = ATTYPE_ID;					  			      factor.value.tok = tok_lastmatched;
		    factor.value.tok = id;						  		      }
		}									  		  }
	    }										  		  else {
	    else if (idsuffix.hasparam) {						  		      factor.value.type = ATTYPE_NOT_EVALUATED;
		if(idsuffix.params.ready) {						  		      pnode = getpnode_token(pn, factor.value.str_, idsuffix.factor_.index)
		    factor.value = *(sem_type_s *)get_semaction(id->lexeme)(curr, NULL, p 		      if(pnode) {
		}									  			  factor.value = getatt(pnode->syn, idsuffix.dot.id);
		if(!factor.value.tok) {							  		      }
		    factor.value.tok = tok_lastmatched;					  		      if(factor.value.type == ATTYPE_NOT_EVALUATED) {
		}									  			  in = get_il(*il, pnode);
	    }										  			  factor.value = getatt(in, idsuffix.dot.id);
	    else {									  		      }
		if(!strcmp(id->lexeme, "null")) {					  		  }
		    factor.value.type = ATTYPE_NULL;					  	      }
		    factor.value.str_ = "null";						  	      break;
		}									  	  case SEMTYPE_NUM:
		else if(!strcmp(id->lexeme, "void")) {					  	      if (!(*curr)->type.attribute) {
		    factor.value.type = ATTYPE_VOID;					  		  factor.value.type = ATTYPE_NUMINT;
		    factor.value.str_ = "void";						  		  factor.value.lexeme = (*curr)->lexeme;
		}									  		  factor.value.int_ = safe_atol((*curr)->lexeme);
		else if(!strcmp(id->lexeme, "newtemp")) {				  	      }
		    factor.value = sem_newtemp(curr);					  	      else {
		}									  		  factor.value.type = ATTYPE_NUMREAL;
		else if(!strcmp(id->lexeme, "newlabel")) {				  		  factor.value.lexeme = (*curr)->lexeme;
		    factor.value = sem_newlabel(curr);					  		  factor.value.real_ = safe_atod((*curr)->lexeme);
		}									  	      }
		else {									  	      factor.value.tok = tok_lastmatched;
		    factor.value.str_ = id->lexeme;					  	      *curr = (*curr)->next;
		    factor.value.lexeme = id->lexeme;					  	      break;







2014-02-11 11:32                                                                         semantics.c                                                                         Page 14


	case SEMTYPE_NOT:								  	  case SEMTYPE_RELOP:
	    *curr = (*curr)->next;							  	  case SEMTYPE_END:
	    id = *curr;									  	  case SEMTYPE_ELSE:
	    factor = sem_factor(parse, curr, il, pda, prod, pn, syn, pass, eval, isfinal) 	  case SEMTYPE_THEN:
	    switch(factor.value.type) {							  	  case SEMTYPE_IF:
		case ATTYPE_ID:								  	  case SEMTYPE_NONTERM:
		    fprintf(stderr, "Type Error: Cannot apply logical not to string type. 	  case SEMTYPE_DOT:
		    break;								  	  case SEMTYPE_CLOSEPAREN:
		case ATTYPE_NUMINT:							  	  case SEMTYPE_CLOSEBRACKET:
		    factor.value.int_ = !factor.value.int_;				  	  case SEMTYPE_COMMA:
		    break;								  	  case SEMTYPE_ASSIGNOP:
		case ATTYPE_NUMREAL:							  	  case SEMTYPE_ID:
		    factor.value.real_ = !factor.value.real_;				  	  case SEMTYPE_ELIF:
		    factor.value.int_ = (long)factor.value.real_;			  	  case LEXTYPE_EOF:
		    factor.value.type = ATTYPE_NUMINT;					  	      factor_.isset = false;
		    break;								  	      factor_.index = 1;
		case ATTYPE_NULL:							  	      break;
		    break;								  	  default:
		default:								  	      fprintf(stderr, "Syntax Error at line %d: Expected [ ] * / + - = < > <> <= >=
		    perror("Illegal State");						  	      assert(false);
		    assert(false);							  	      break;
		    break;								      }
	    }										      return factor_;
	    break;									  }
	case SEMTYPE_OPENPAREN:								  
	    *curr = (*curr)->next;							  sem_idsuffix_s sem_idsuffix(parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, pro
	    expression = sem_expression(parse, curr, il, pda, prod, pn, syn, pass, eval,  {
	    sem_match(curr, SEMTYPE_CLOSEPAREN);					      sem_expression_s expression;
	    factor.value = expression.value;						      sem_idsuffix_s idsuffix;
	    break;									  
	case SEMTYPE_CODE:								      expression.value.str_ = NULL;
	    factor.value.type = ATTYPE_CODE;						      switch ((*curr)->type.val) {
	    factor.value.str_ = (*curr)->lexeme_;					  	  case SEMTYPE_COMMA:
	    factor.value.tok = tok_lastmatched;						  	  case SEMTYPE_CLOSEPAREN:
	    *curr = (*curr)->next;							  	  case SEMTYPE_CLOSEBRACKET:
	    break;									  	  case SEMTYPE_MULOP:
	default:									  	  case SEMTYPE_ADDOP:
	    fprintf(stderr, "Syntax Error at line %d: Expected identifier nonterm number  	  case SEMTYPE_RELOP:
	    assert(false);								  	  case SEMTYPE_END:
	    break;									  	  case SEMTYPE_ELSE:
    }											  	  case SEMTYPE_THEN:
    return factor;									  	  case SEMTYPE_IF:
}											  	  case SEMTYPE_DOT:
											  	  case SEMTYPE_NONTERM:
sem_factor__s sem_factor_(parse_s *parse, token_s **curr, llist_s **il, pna_s *pn, semant 	  case SEMTYPE_NUM:
{											  	  case SEMTYPE_ID:
    sem_factor__s factor_;								  	  case SEMTYPE_ELIF:
											  	  case LEXTYPE_EOF:
    switch((*curr)->type.val) {								  	      idsuffix.factor_ = sem_factor_(parse, curr, il, pn, syn, pass, eval, isfinal)
	case SEMTYPE_NUM:								  	      idsuffix.dot = sem_dot(parse, curr, il, pn, syn, pass, eval, isfinal);
	    factor_.isset = true;							  	      idsuffix.hasparam = false;
	    factor_.index = (unsigned)safe_atol((*curr)->lexeme);			  	      idsuffix.hasmap = false;
	    *curr = (*curr)->next;							  	      break;
	    break;									  	  case SEMTYPE_OPENPAREN:
	case SEMTYPE_MULOP:								  	      *curr = (*curr)->next;
	case SEMTYPE_ADDOP:								  	      idsuffix.hasparam = true;







2014-02-11 11:32                                                                         semantics.c                                                                         Page 15


	    idsuffix.hasmap = false;							  	  case SEMTYPE_ELIF:
	    idsuffix.params = sem_paramlist(parse, curr, il, pda, prod, pn, syn, pass, ev 	  case LEXTYPE_EOF:
	    idsuffix.factor_.index = 1;							  	      dot.id = NULL;
	    idsuffix.factor_.isset = false;						  	      dot.range.isset = false;
	    idsuffix.dot.id = NULL;							  	      break;
	    sem_match(curr, SEMTYPE_CLOSEPAREN);					  	  default:
	    break;									  	      fprintf(stderr, "Syntax Error at line %d: Expected . ] * / + - = < > <> <= >=
	case SEMTYPE_OPENBRACKET:							  	      assert(false);
	    *curr = (*curr)->next;							  	      break;
	    expression = sem_expression(parse, curr, il, pda, prod, pn, syn, pass, eval,      }
	    sem_match(curr, SEMTYPE_CLOSEBRACKET);					      return dot;
	    idsuffix.factor_.isset = true;						  }
	    idsuffix.factor_.index = 1;							  
	    idsuffix.dot = sem_dot(parse, curr, il, pn, syn, pass, eval, isfinal);	  sem_range_s sem_range(parse_s *parse, token_s **curr, llist_s **il, pna_s *pn, semantics_
	    idsuffix.hasparam = false;							  {
	    idsuffix.hasmap = false;							      unsigned index;
	    break;									      token_s *id1, *id2;
	case SEMTYPE_MAP:								      sem_range_s range;
	    *curr = (*curr)->next;							      pnode_s *p;
	    idsuffix.hasmap = true;							  
	    idsuffix.hasparam = false;							      switch ((*curr)->type.val) {
	    idsuffix.dot.id = NULL;							  	  case SEMTYPE_DOT:
	    idsuffix.factor_.isset = false;						  	      *curr = (*curr)->next;
	    break;									  	      sem_match(curr, SEMTYPE_DOT);
	default:									  	      id1 = *curr;
	    fprintf(stderr, "Syntax Error at line %d: Expected , ] [ * / + - = < > <> <=  	      sem_match(curr, SEMTYPE_ID);
	    assert(false);								  	      sem_match(curr, SEMTYPE_OPENBRACKET);
	    break;									  	      index = (unsigned)safe_atol((*curr)->lexeme);
    }											  	      sem_match(curr, SEMTYPE_NUM);
    return idsuffix;									  	      sem_match(curr, SEMTYPE_CLOSEBRACKET);
}											  	      sem_match(curr, SEMTYPE_DOT);
											  	      id2 = *curr;
sem_dot_s sem_dot(parse_s *parse, token_s **curr, llist_s **il, pna_s *pn, semantics_s *s 	      sem_match(curr, SEMTYPE_ID);
{											  	      p = getpnode_token(pn, id1->lexeme, index);
    sem_dot_s dot;									  	      range.isset = true;
											  	      if(p && p->pass) {
    switch((*curr)->type.val) {								  		  range.value = safe_atol(p->matched->lexeme);
	case SEMTYPE_DOT:								  		  range.isready = true;
	    *curr = (*curr)->next;							  	      }
	    dot.id = (*curr)->lexeme;							  	      else
	    sem_match(curr, SEMTYPE_ID);						  		  range.isready = false;
	    dot.range = sem_range(parse, curr, il, pn, syn, pass, eval, isfinal);	  	      break;
	    break;									  	  case SEMTYPE_COMMA:
	case SEMTYPE_MULOP:								  	  case SEMTYPE_CLOSEBRACKET:
	case SEMTYPE_ADDOP:								  	  case SEMTYPE_MULOP:
	case SEMTYPE_RELOP:								  	  case SEMTYPE_ADDOP:
	case SEMTYPE_END:								  	  case SEMTYPE_RELOP:
	case SEMTYPE_ELSE:								  	  case SEMTYPE_END:
	case SEMTYPE_THEN:								  	  case SEMTYPE_CLOSEPAREN:
	case SEMTYPE_IF:								  	  case SEMTYPE_ID:
	case SEMTYPE_NONTERM:								  	  case SEMTYPE_ELSE:
	case SEMTYPE_CLOSEPAREN:							  	  case SEMTYPE_THEN:
	case SEMTYPE_CLOSEBRACKET:							  	  case SEMTYPE_IF:
	case SEMTYPE_COMMA:								  	  case SEMTYPE_ASSIGNOP:
	case SEMTYPE_ID:								  	  case SEMTYPE_NONTERM:
	case SEMTYPE_ASSIGNOP:								  	  case SEMTYPE_ELIF:







2014-02-11 11:32                                                                         semantics.c                                                                         Page 16


	case LEXTYPE_EOF:								  		  list->ready = false;
	    range.isready = true;							  	      else if (list->ready)
	    range.isset = false;							  		  llpush(&list->pstack, alloc_semt(expression.value));
	    range.value = 1;								  	      sem_paramlist_(parse, curr, il, list, pda, prod, pn, syn, pass, eval, isfinal
	    break;									  	      break;
	default:									  	  case SEMTYPE_CLOSEPAREN:
	    fprintf(stderr, "Syntax Error at line %d: Expected . , ] * / and or + - = < > 	      break;
	    assert(false);								  	  default:
	    break;									  	      fprintf(stderr, "Syntax Error at line %d: Expected , or ( but got %s\n", (*cu
    }											  	      assert(false);
    return range;									  	      break;
}											      }
											  }
sem_paramlist_s sem_paramlist(parse_s *parse, token_s **curr, llist_s **il, pda_s *pda, p 
{											  sem_sign_s sem_sign(token_s **curr)
    sem_paramlist_s paramlist;								  {
    sem_expression_s expression;							      sem_sign_s sign;
											  
    expression.value.str_ = NULL;							      if ((*curr)->type.val == SEMTYPE_ADDOP) {
    paramlist.ready = true;								  	  sign.value = (*curr)->type.attribute;
    paramlist.pstack = NULL;								  	  *curr = (*curr)->next;
											  	  return sign;
    switch((*curr)->type.val) {								      }
	case SEMTYPE_ADDOP:								      else {
	case SEMTYPE_CODE:								  	  fprintf(stderr, "Syntax Error at line %d: Expected + or - but got %s\n", (*curr)-
	case SEMTYPE_NOT:								  	  assert(false);
	case SEMTYPE_NUM:								      }
	case SEMTYPE_OPENPAREN:								  }
	case SEMTYPE_ID:								  
	case SEMTYPE_NONTERM:								  bool sem_match(token_s **curr, int type)
	    expression = sem_expression(parse, curr, il, pda, prod, pn, syn, pass, eval,  {
	    if(expression.value.type == ATTYPE_NOT_EVALUATED || expression.value.type ==      if ((*curr)->type.val == type) {
		paramlist.ready = false;						  	  *curr = (*curr)->next;
	    else									  	  return true;
		llpush(&paramlist.pstack, alloc_semt(expression.value));		      }
	    sem_paramlist_(parse, curr, il, &paramlist, pda, prod, pn, syn, pass, eval, i     fprintf(stderr, "Syntax Error at line %d: Got %s\n", (*curr)->lineno, (*curr)->lexeme
	    break;									      assert(false);
	case SEMTYPE_CLOSEPAREN:							      return false;
	    break;									  }
	default:									  
	    fprintf(stderr, "Syntax Error at line %d: Expected + - code not number ( iden sem_type_s *alloc_semt(sem_type_s value)
	    assert(false);								  {
	    break;									      sem_type_s *val;
    }											  
    return paramlist;									      val = malloc(sizeof(*val));
}											      if (!val) {
											  	  perror("Memory Allocation Error");
void sem_paramlist_(parse_s *parse, token_s **curr, llist_s **il, sem_paramlist_s *list,  	  exit(EXIT_FAILURE);
{											      }
    sem_expression_s expression;							      *val = value;
											      return val;
    switch ((*curr)->type.val) {							  }
	case SEMTYPE_COMMA:								  
	    *curr = (*curr)->next;							  att_s *att_s_(void *data, unsigned tid)
	    expression = sem_expression(parse, curr, il, pda, prod, pn, syn, pass, eval,  {
	    if(expression.value.type == ATTYPE_NOT_EVALUATED || expression.value.type ==      att_s *att;







2014-02-11 11:32                                                                         semantics.c                                                                         Page 17


											  }
    att = malloc(sizeof(*att));								  
    if (!att) {										  void *sem_emit(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pn, parse_s *parse, sem
	perror("Memory Allocation Error");						  {
	exit(EXIT_FAILURE);								      int c;
    }											      size_t lsize = 32;
    att->tid = tid;									      char *out = NULL;
    att->lexeme = data;									      size_t len;
    return att;										      llist_s *iter;
}											      sem_type_s *dummy;
											      sem_type_s *val;
void setatt(semantics_s *s, char *id, sem_type_s *data)					      bool gotfirst = false, gotlabelf = false, gotlabell = false;
{											      char *line = NULL;
    if(data->type != ATTYPE_NOT_EVALUATED && data->type != ATTYPE_NULL) {		  
	hashinsert_(s->table, id, data);						      if(hashlookup(grammar_stack->ptr, *curr))
    }											  	  return NULL;
}											  
											      if(params.ready && eval) {
sem_type_s getatt(semantics_s *s, char *id)						  	  llreverse(&params.pstack);
{											  
    sem_type_s dummy = {0};								  	  while((iter = llpop(&params.pstack))) {
    sem_type_s *data;									  	      val = iter->ptr;
											  	      free(iter);
    dummy.type = ATTYPE_NOT_EVALUATED;							  
    dummy.str_ = NULL;									  
    if(!s)										  	      if(!gotfirst) {
	return dummy;									  		  if(val->type == ATTYPE_ID) {
											  		      if(!strcmp(val->str_, "labelf")) {
    data = hashlookup(s->table, id);							  			  gotfirst = true;
    if (!data)										  			  gotlabelf = true;
	return dummy;									  			  continue;
    return *data;									  		      }
}											  		      else if(!strcmp(val->str_, "label")) {
											  			  gotfirst = true;
void *sem_array(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pn, parse_s *p, sem_pa 			  gotlabell = true;
{											  			  continue;
    llist_s *node;									  		      }
    sem_type_s *val1, *val2;								  		  }
											  		  safe_addstring(&line, "\t");
    node = llpop(&params.pstack);							  		  gotfirst = true;
    val1 = node->ptr;									  	      }
    free(node);										  
    node = llpop(&params.pstack);							  	      switch(val->type) {
    val2 = node->ptr;									  		  case ATTYPE_CODE:
    free(node);										  		      len = strlen(val->str_);
											  		      out = malloc(len-1);
    val1->lexeme = malloc(strlen(val1->str_) + 1);					  		      if(!out){
    if(!val1->lexeme) {									  			  perror("Memory Allocation Error");
	perror("Memory Allocation Error");						  			  exit(EXIT_FAILURE);
	exit(EXIT_FAILURE);								  		      }
    }											  		      c = val->str_[len-1];
    strcpy(val1->lexeme, val1->str_);							  		      val->str_[len-1] = '\0';
    val1->low = val2->low;								  		      strcpy(out, &val->str_[1]);
    val1->high = val2->high;								  		      val->str_[len-1] = c;
    val1->type = ATTYPE_ARRAY;								  		      safe_addstring(&line, out);
    return val1;									  		      free(out);







2014-02-11 11:32                                                                         semantics.c                                                                         Page 18


		    break;								  	  else
		case ATTYPE_NUMINT:							  	      add_semerror(parse, tok_lastmatched, str);
		    safe_addint(&line, val->int_);					  	  hashinsert(grammar_stack->ptr, *curr, val);
		    break;								      }
		case ATTYPE_NUMREAL:							      return NULL;
		    safe_adddouble(&line, val->real_);					  }
		    break;								  
		case ATTYPE_ID:								  void *sem_getarray(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pn, parse_s *parse,
		case ATTYPE_TEMP:							  {
		case ATTYPE_LABEL:							      pnode_s *p = NULL;
		    if(gotlabelf) {							      llist_s *node = NULL;
			safe_addstring(&line, scope_tree->full_id);			      sem_type_s *val = NULL, type = {0};
			gotlabelf = false;						      check_id_s check = {0};
		    }									  
		    else {								      if(params.ready && eval) {
			safe_addstring(&line, val->str_);				  	  node = llpop(&params.pstack);
		    }									  	  val = node->ptr;
											  	  free(node);
		    break;								  
		default:								  	  p = getpnode_nterm_copy(pn, val->str_, 1);
		    break;								  	  type = gettype(parse->lex, p->matched->lexeme);
	    }										  
											  	  if(type.type == ATTYPE_ARRAY) {
	}										  	      type.type = ATTYPE_ID;
	addline(&scope_tree->code, line);						  	      check = check_id(p->matched->lexeme);
	dummy = (sem_type_s *)1;							  	      if(!check.isfound && isfinal) {
	hashinsert(grammar_stack->ptr, *curr, dummy);					  		  check = check_id(p->matched->lexeme);
    }											  		  add_semerror(parse, p->matched, "undeclared identifier");
    return NULL;									  	      }
}											  	  }
											  	  else if(eval) {
void *sem_error(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pn, parse_s *parse, se 	      if(type.type == ATTYPE_NULL)
{											  		  add_semerror(parse, p->matched, "undeclared identifier");
    char *str;										  	      else
    pnode_s *p;										  		  add_semerror(parse, p->matched, "attempt to index non-array identifier");
    llist_s *node;									  	  }
    sem_type_s *val, *id;								      }
											      return alloc_semt(type);
    if(hashlookup(grammar_stack->ptr, *curr))						  }
	return NULL;									  
											  void *sem_gettype(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pn, parse_s *parse,
    if(params.ready && eval) {								  {
	node = llpop(&params.pstack);							      llist_s *node;
	val = node->ptr;								      sem_type_s *val;
	free(node);									  
											      if(params.ready) {
	node = llpop(&params.pstack);							  	  node = llpop(&params.pstack);
	id = node->ptr;									  	  val = node->ptr;
	free(node);									  	  free(node);
											  	  //parse->lex->machs
	str = val->str_;								  	  switch(val->type) {
	str[0] = ' ';									  
	str[strlen(str)-1] = ' ';							  	  }
	p = getpnode_nterm_copy(pn, id->str_, 1);					  
	if(p)										      }
	    add_semerror(parse, p->matched, str);					  }







2014-02-11 11:32                                                                         semantics.c                                                                         Page 19


											      llist_s *node;
void *sem_halt(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pn, parse_s *p, sem_par     sem_type_s *t, *id;
{											      token_s *temp;
    if(!eval)										      bool declared;
	return NULL;									      check_id_s check;
    printf("Halt Called in %s\n", pda->nterm->lexeme);					  
    fflush(stderr);									      if(hashlookup(grammar_stack->ptr, *curr))
    fflush(stdout);									  	  return NULL;
    asm("hlt");										  
    assert(false);									      if(!(params.ready && eval))
}											  	  return NULL;
											  
void *sem_lookup(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pn, parse_s *parse, s     node = llpop(&params.pstack);
{											      t = node->ptr;
    pnode_s *p;										      free(node);
    llist_s *node;									  
    sem_type_s *val, type;								      node = llpop(&params.pstack);
											      id = node->ptr;
    if(params.ready) {									      free(node);
	node = llpop(&params.pstack);							      declared = check_redeclared(id->lexeme);
	val = node->ptr;								      check = check_id(id->lexeme);
	free(node);									  
											      if(declared && (check.type->type != ATTYPE_NULL && check.type->type != ATTYPE_NOT_EVA
	p = getpnode_nterm_copy(pn, val->str_, 1);					  	  temp = malloc(sizeof(*temp));
	type = gettype(parse->lex, p->matched->lexeme);					  	  if(!temp) {
	if((type.type == ATTYPE_NULL || !check_id(p->matched->lexeme).isfound) && eval && 	      perror("Memory Allocation Error");
	    add_semerror(parse, p->matched, "undeclared identifier");			  	      exit(EXIT_FAILURE);
	}										  	  }
	return alloc_semt(type);							  	  temp->lineno = id->tok->lineno;
    }											  	  strcpy(temp->lexeme, id->lexeme);
    return NULL;									  	  add_semerror(p, temp, "Redeclaration of identifier");
}											  	  hashinsert(grammar_stack->ptr, *curr, *curr);
											      }
void *sem_print(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pn, parse_s *p, sem_pa     else {
{											  	  t->tok = id->tok;
    llist_s *node;									  	  if(!declared) {
    sem_type_s *val;									  	     if(t->type != ATTYPE_ARGLIST_FORMAL)
											  		  add_id(id->lexeme, *t, true);
    if(!(params.ready && eval))								  	  }
	return NULL;									  	  settype(p->lex, id->lexeme, *t);
											  	  if(t->type != ATTYPE_NULL && t->type != ATTYPE_NOT_EVALUATED) {
    llreverse(&params.pstack);								  	      hashinsert(grammar_stack->ptr, *curr, *curr);
    while (params.pstack) {								  	  }
	node = llpop(&params.pstack);							      }
	val = node->ptr;								      return NULL;
	print_semtype(*val);								  }
	free(node);									  
	free(val);									  void *sem_addarg(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *p, sem_
    }											  {
    putchar('\n');									      llist_s *node;
    fflush(stdout);									      sem_type_s *t, *id, test;
    return NULL;									      token_s *temp;
}											      bool declared;
											  
void *sem_addtype(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pn, parse_s *p, sem_     if(hashlookup(grammar_stack->ptr, *curr))
{											  	  return NULL;







2014-02-11 11:32                                                                         semantics.c                                                                         Page 20


											  }
    if(!(params.ready && eval))								  
	return NULL;									  void *sem_makelista(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *pars
											  {
    node = llpop(&params.pstack);							      llist_s *node = NULL;
    t = node->ptr;									      sem_type_s *t = NULL, *final = NULL, list = {0};
    free(node);										  
											      if((final = hashlookup(grammar_stack->ptr, *curr)))
    node = llpop(&params.pstack);							  	  return final;
    id = node->ptr;									  
    free(node);										      if(!(params.ready && eval))
											  	  return NULL;
    declared = check_redeclared(id->lexeme);						  
    test = gettype(p->lex, id->lexeme);							      node = llpop(&params.pstack);
    if(declared && (test.type != ATTYPE_NOT_EVALUATED && test.type != ATTYPE_NULL)) {	  
	temp = malloc(sizeof(*temp));							      t = node->ptr;
	if(!temp) {									      free(node);
	    perror("Memory Allocation Error");						  
	    exit(EXIT_FAILURE);								      list.type = ATTYPE_ARGLIST_ACTUAL;
	}										      list.q = queue_s_();
	temp->lineno = id->tok->lineno;							      list.lexeme = "--ARGLIST--";
	strcpy(temp->lexeme, id->lexeme);						      enqueue(list.q, t);
	add_semerror(p, temp, "Redeclaration of identifier");				  
    }											      final = alloc_semt(list);
    else {										      hashinsert(grammar_stack->ptr, *curr, final);
	t->tok = id->tok;								      return final;
	add_id(id->lexeme, *t, false);							  }
	settype(p->lex, id->lexeme, *t);						  
    }											  void *sem_makelistf(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *pars
    hashinsert(grammar_stack->ptr, *curr, *curr);					  {
    return NULL;									      llist_s *node = NULL;
}											      sem_type_s *t = NULL, *final = NULL, list = {0};
											  
void *sem_listappend(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *par     if((final = hashlookup(grammar_stack->ptr, *curr)))
{											  	  return final;
    llist_s *listparam, *argparam;							  
    sem_type_s *arglist, *arg;								      if(!(params.ready && eval))
											  	  return NULL;
    if(hashlookup(grammar_stack->ptr, *curr))						  
	return NULL;									      node = llpop(&params.pstack);
											  
    if(!(params.ready && eval))								      t = node->ptr;
	return NULL;									      free(node);
											  
    argparam = llpop(&params.pstack);							      list.type = ATTYPE_ARGLIST_FORMAL;
    arg = argparam->ptr;								      list.q = queue_s_();
    free(argparam);									      list.lexeme = "--ARGLIST--";
											  
    listparam = llpop(&params.pstack);							      enqueue(list.q, t);
    arglist = listparam->ptr;								      final = alloc_semt(list);
    free(listparam);									      hashinsert(grammar_stack->ptr, *curr, final);
											      return final;
    enqueue(arglist->q, arg);								  }
    hashinsert(grammar_stack->ptr, *curr, *curr);					  
											  void *sem_pushscope(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *pars
    return NULL;									  {







2014-02-11 11:32                                                                         semantics.c                                                                         Page 21


    llist_s *node;									  void *sem_resolveproc(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *pa
    sem_type_s *final, *arg;								  {
    check_id_s check;									      llist_s *node;
    token_s *temp;									      check_id_s check;
    bool declared;									      sem_type_s dummy = {0}, *proc, copy;
											  
    if((final = hashlookup(grammar_stack->ptr, *curr)))					      dummy.type = ATTYPE_NOT_EVALUATED;
	return final;									      if(!(params.ready && eval))
											  	  return alloc_semt(dummy);
    if(!(params.ready && eval))								  
	return NULL;									      node = llpop(&params.pstack);
											      proc = node->ptr;
    node = llpop(&params.pstack);							  
    arg = node->ptr;									      check = check_id(proc->str_);
    free(node);										      if(check.isfound) {
											  	  copy = *proc;
    declared = check_redeclared(arg->str_);						  	  copy.str_ = check.scope->full_id;
    check = check_id(arg->str_);							  	  copy.lexeme = check.scope->full_id;
    if(declared && check.type) {							  	  return alloc_semt(copy);
	temp = malloc(sizeof(*temp));							      }
	if(!temp) {									      dummy.type = ATTYPE_NULL;
	    perror("Memory Allocation Error");						      return alloc_semt(dummy);
	    exit(EXIT_FAILURE);								  }
	}										  
	temp->lineno = arg->tok->lineno;						  void *sem_getwidth(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *parse
	strcpy(temp->lexeme, arg->str_);						  {
	add_semerror(parse, temp, "Redeclaration of identifier as procedure");		      char *str = NULL;
    }											      llist_s *node = NULL;
    push_scope(arg->str_);								      pnode_s *p = NULL;
    scope_tree->full_id = scoped_label();						      sem_type_s id = {0}, width = {0};
    final = (sem_type_s *)1;								      check_id_s check = {0};
    hashinsert(grammar_stack->ptr, *curr, final);					  
    return NULL;									      id.type = ATTYPE_NOT_EVALUATED;
}											      if(!(params.ready && eval))
											  	  return alloc_semt(id);
void *sem_popscope(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *parse     node = llpop(&params.pstack);
{											      id = *(sem_type_s *)node->ptr;
    sem_type_s *final;									      p = getpnode_nterm_copy(pna, id.str_, 1);
											      str = p->matched->lexeme;
    if((final = hashlookup(grammar_stack->ptr, *curr)))					      check = check_id(str);
	return final;									      width.type = ATTYPE_NUMINT;
											      width.int_ = check.width;
    if(!(params.ready && eval))								      return alloc_semt(width);
	return NULL;									  }
    pop_scope();									  
    final = (sem_type_s *)1;								  void *sem_low(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *parse, sem
    hashinsert(grammar_stack->ptr, *curr, final);					  {
    return NULL;									      char *str = NULL;
}											      llist_s *node = NULL;
											      pnode_s *p = NULL;
void *sem_resettemps(token_s **curr, semantics_s *s, pda_s *pda, pna_s *pna, parse_s *par     sem_type_s id = {0}, low = {0};
{											      check_id_s check = {0};
    tempcount = 0;									  
    return NULL;									      id.type = ATTYPE_NOT_EVALUATED;
}											      if(!(params.ready && eval))
											  	  return alloc_semt(id);







2014-02-11 11:32                                                                         semantics.c                                                                         Page 22


    node = llpop(&params.pstack);							      la_last = la = actual.q->head;
    id = *(sem_type_s *)node->ptr;							      for(lf = formal.q->head; lf && la; lf = lf->next, la_last = la, la = la->next) {
    p = getpnode_nterm_copy(pna, id.str_, 1);						  	  f = lf->ptr;
    if(!p) {										  	  a = la->ptr;
	id.type = ATTYPE_NULL;								  
	return alloc_semt(id);								  	  if(f->type == ATTYPE_ID){
    }											  	      if(a->type == ATTYPE_ID){
    str = p->matched->lexeme;								  		  if(!strcmp(f->str_, "real")){
    check = check_id(str);								  		      if(strcmp(a->str_, "real") && strcmp(a->str_, "integer")) {
    low.type = ATTYPE_NUMINT;								  			  add_semerror(parse, a->tok, "Expected real or integer but got dif
    if(!check.isfound) {								  			  *result = 0;
	low.type = ATTYPE_NULL;								  		      }
	low.int_ = 0;									  		  }
    }											  		  else if(!strcmp(f->str_, "integer")){
    else if(check.type->type == ATTYPE_ARRAY)						  		      if(strcmp(a->str_, "integer")) {
	low.int_ = check.type->low;							  			  add_semerror(parse, a->tok, "Expected integer but got different t
    else										  			  *result = 0;
	low.int_ = 0;									  		      }
    return alloc_semt(low);								  		  }
}											  	      }
											  	      else if(a->type == ATTYPE_ARRAY){
int arglist_cmp(token_s **curr, parse_s *parse, token_s *tok, sem_type_s formal, sem_type 		  add_semerror(parse, a->tok, "Expected real or integer but got array");
{											  		  *result = 0;
    llist_s *lf, *la, *la_last;								  	      }
    sem_type_s *a, *f;									  	      else{
    int *result;									  		  add_semerror(parse, a->tok, "Expected real or integer but got different t
											  		  *result = 0;
    if((result = hashlookup(grammar_stack->ptr, *curr)))				  	      }
	return *result;									  	  }
    result = malloc(sizeof(*result));							  	  else if(f->type == ATTYPE_ARRAY){
    if(!result) {									  	      if(a->type == ATTYPE_ARRAY){
	perror("Memory Allocation Error");						  		  if(strcmp(f->str_, a->str_)) {
	exit(EXIT_FAILURE);								  		      add_semerror(parse, a->tok, "Array types mismatch");
    }											  		      *result = 0;
    switch(actual.type) {								  		  }
	case ATTYPE_ARGLIST_ACTUAL:							  		  if(f->low != a->low || f->high != a->high) {
	    break;									  		      add_semerror(parse, a->tok, "Array bounds mismatch");
	case ATTYPE_ID:									  		      *result = 0;
	case ATTYPE_ARRAY:								  		  }
	default:									  	      }
	    add_semerror(parse, actual.tok, "Improper assignment involving procedure type 	      else if(a->type == ATTYPE_ID){
	    *result = 0;								  		  add_semerror(parse, a->tok, "Exptected array type but got numeric type");
	    hashinsert(grammar_stack->ptr, *curr, result);				  		  *result = 0;
	    return 0;									  	      }
    }											  	      else{
    switch(formal.type) {								  		  add_semerror(parse, a->tok, "Exptected array type but got other type");
	case ATTYPE_ARGLIST_FORMAL:							  		  *result = 0;
	    break;									  	      }
	case ATTYPE_ID:									  	  }
	case ATTYPE_ARRAY:								  	  else if(f->type == ATTYPE_VOID) {
	default:									  	      if(a->type != ATTYPE_VOID) {
	    add_semerror(parse, actual.tok, "Attempt to call non-procedure object");	  		  add_semerror(parse, a->tok, "Excess Parameters Used in function call");
	    *result = 0;								  		  *result = 0;
	    hashinsert(grammar_stack->ptr, *curr, result);				  	      }
	    return 0;									  	  }
    }											      }







2014-02-11 11:32                                                                         semantics.c                                                                         Page 23


    if(la) {										  
	if(la_last->next)								  char *semstr_concat(char *base, sem_type_s val)
	    la_last = la_last->next;							  {
	add_semerror(parse, ((sem_type_s *)la_last->ptr)->tok, "Excess Parameters Used in     char *str = sem_tostring(val);
	*result = 0;									  
											      if (!base) {
    }											  	  base = malloc(sizeof(*base) + strlen(str) + 1);
    else if(lf) {									  	  if (!base) {
	add_semerror(parse, ((sem_type_s *)la_last->ptr)->tok, "Not Enough Arguments Used 	      perror("Memory Allocation Error");
	*result = 0;									  	      exit(EXIT_FAILURE);
    }											  	  }
    *result = 1;									      }
    hashinsert(grammar_stack->ptr, *curr, result);					      else
    return *result;									  	  base = realloc(base, strlen(base) + strlen(str) + 1);
}											      strcat(base, str);
											      return base;
int ftable_strcmp(char *key, ftable_s *b)						  }
{											  
    return strcasecmp(key, b->key);							  void set_type(semantics_s *s, char *id, sem_type_s type)
}											  {
											      tdat_s tdat;
sem_action_f get_semaction(char *str)							      idtable_s *table = s->parse->lex->idtable;
{											  
    ftable_s *rec;									      tdat = idtable_lookup(table, id).tdat;
											      tdat.type = type;
    rec = bsearch(str, ftable, FTABLE_SIZE, sizeof(*ftable), (int (*)(const void *, const     idtable_set(table, id, tdat);
    if (!rec) {										  }
	fprintf(stderr, "Error: Undefined function: %s\n", str);			  
	assert(false);									  sem_type_s get_type(semantics_s *s, char *id)
    }											  {
    return rec->action;									      tdat_s tdat;
}											      idtable_s *table = s->parse->lex->idtable;
											      tdat = idtable_lookup(table, id).tdat;
char *sem_tostring(sem_type_s type)							      return tdat.type;
{											  }
    char *stralloc = NULL;								  
											  void free_sem(semantics_s *s)
    switch(type.type) {									  {
	case ATTYPE_ID:									      if(s) {
	case ATTYPE_CODE:								  	  free_hash(s->table);
	    return type.str_;								  	  free(s);
	case ATTYPE_NUMINT:								      }
	    stralloc = malloc(FS_INTWIDTH_DEC(type.int_)+1);				  }
	    if (stralloc) {								  
		perror("Memory Allocation Error");					  semantics_s *get_il(llist_s *l, pnode_s *p)
		exit(EXIT_FAILURE);							  {
	    }										      if(!p)
	    sprintf(stralloc, "%ld", type.int_);					  	  return NULL;
	    break;									      while(l) {
	case ATTYPE_NUMREAL:								  	  if(((semantics_s *)l->ptr)->n->self == p->self)
											  	      return l->ptr;
	default:									  	  l = l->next;
	    break;									      }
    }											      return NULL;
    return stralloc;									  }
}											  







2014-02-11 11:32                                                                         semantics.c                                                                         Page 24


char *make_semerror(unsigned lineno, char *lexeme, char *message)			      value.str_ = malloc(FS_INTWIDTH_DEC(tempcount)+40);
{											      if(!value.str_) {
    char *msg;										  	  perror("Memory Allocation Error");
    size_t stlenl = strlen(lexeme);							  	  exit(EXIT_FAILURE);
    size_t stlenm = strlen(message);							      }
											      value.lexeme = value.str_;
    msg = calloc(1, sizeof(TYPE_ERROR_PREFIX) + sizeof(TYPE_ERROR_SUFFIX) + FS_INTWIDTH_D     sprintf(value.str_, "_L%u", lablecount++);
    if(!msg) {										  
	perror("Memory Allocation Error");						      hashinsert(grammar_stack->ptr, *curr, alloc_semt(value));
	exit(EXIT_FAILURE);								      return value;
    }											  }
    sprintf(msg, TYPE_ERROR_PREFIX "%s" TYPE_ERROR_SUFFIX, lineno, message, lexeme);	  
    msg[sizeof(TYPE_ERROR_PREFIX) + sizeof(TYPE_ERROR_SUFFIX) + FS_INTWIDTH_DEC(lineno) + char *scoped_label(void)
    return msg;										  {
}											      bool gotfirst = false;
											      char *str, *label = NULL;
void add_semerror(parse_s *p, token_s *t, char *message)				      llist_s *l = NULL, *node = NULL;
{											      scope_s *s;
    char *err = make_semerror(t->lineno, t->lexeme, message);				  
											      for(s = scope_tree; s; s = s->parent)
    if(check_listing(p->listing, t->lineno, err))					  	  llpush(&l, s->id);
	free(err);									  
    else										      while((node = llpop(&l)))	 {
	adderror(p->listing, err, t->lineno);						  	  str = node->ptr;
}											  	  free(node);
											  
sem_type_s sem_newtemp(token_s **curr)							  	  if(gotfirst)
{											  	      safe_addstring(&label, "_");
    sem_type_s value, *hash;								  	  else {
											  	      safe_addstring(&label, "__");
    if((hash = hashlookup(grammar_stack->ptr, *curr)))					  	      gotfirst = true;
	return *hash;									  	  }
											  	  safe_addstring(&label, str);
    value.type = ATTYPE_TEMP;								      }
    value.str_ = malloc(FS_INTWIDTH_DEC(tempcount)+4);					      return label;
    if(!value.str_) {									  }
	perror("Memory Allocation Error");						  
	exit(EXIT_FAILURE);								  
    }											  void write_code(void)
    value.lexeme = value.str_;								  {
    sprintf(value.str_, "_t%u", tempcount++);						      write_code_(scope_root);
											  }
    hashinsert(grammar_stack->ptr, *curr, alloc_semt(value));				  
    return value;									  void write_code_(scope_s *s)
}											  {
											      unsigned i;
sem_type_s sem_newlabel(token_s **curr)							  
{											      if(!s)
    sem_type_s value, *hash;								  	  return;
											      print_listing_nonum(s->code, emitdest);
    if((hash = hashlookup(grammar_stack->ptr, *curr)))					      for(i = 0; i < s->nchildren; i++)
	return *hash;									  	  write_code_(s->children[i].child);
											  }
    value.type = ATTYPE_LABEL;







