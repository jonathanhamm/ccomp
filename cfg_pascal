<program> ->
	program id \( <identifier_list> \) ;
	<program'>
	<compound_statement>
	\.
	{
	}

<program'> ->
	<declarations> <dec>
	{
    }
	|
	<subprogram_declarations>
	{}
	|
	ε

<dec> ->
	<subprogram_declarations>
	|
	ε

<identifier_list> ->
	id <identifier_list'>
	{
	}
<identifier_list'> ->
	, id <identifier_list'>
	{
	}
	|
	ε

<declarations> ->
	var id : <type> ; <declarations'> 
    {
        addtype(id.entry, <type>.type)
    }
<declarations'> ->
	var id : <type> ; <declarations'>
    {
        addtype(id.entry, <type>.type)
    }
	|
	ε

<type> ->
	<standard_type>
    {
        <type>.type := <standard_type>.type
    }
	|
	array \[ num \. \. num \] of <standard_type>
    {
        <type>.type := array(num[1].val .. num[2].val, <standard_type>.type)
    }

<standard_type> ->
	integer
    {
        <standard_type>.type := integer

    }
	|
	real
    { 
        <standard_type>.type := real
    }
	
<subprogram_declarations> ->
	<subprogram_declaration> ; <subprogram_declarations'>
<subprogram_declarations'> ->
	<subprogram_declaration> ; <subprogram_declarations'>
	|
	ε

<subprogram_declaration> ->
	<subprogram_head>
	<subprogram_declaration'>
	<compound_statement>
<subprogram_declaration'> ->
	<declarations> <dec>
	|
	<subprogram_declarations>
	|
	ε

<subprogram_head> ->
	procedure id <subprogram_head'>;
<subprogram_head'> ->
	<arguments>
	|
	ε

<arguments> ->
	\( <parameter_list> \)
<parameter_list> ->
	id : <type> <parameter_list'> { addtype(id.entry, <type>.type) }
<parameter_list'> ->
	; id : <type> <parameter_list'> { addtype(id.entry, <type>.type) }
	|
	ε
	
<compound_statement> ->
	begin
	<compound_statement'>
	end
<compound_statement'> ->
	<optional_statements>
	|
	ε
	
<optional_statements> ->
	<statement_list>

<statement_list> ->
	<statement> <statement_list'>
<statement_list'> ->
	; <statement> <statement_list'>
	|
	ε

<statement> ->
	<variable> assignop <expression>
	|
	<procedure_statement>
	|
	<compound_statement>
	|
	while <expression> do <statement>
	|
	if <expression> then <statement> <statement'>
<statement'> ->
	else <statement>
	|
	ε
	
<variable> ->
	id <variable'> 
    {
        if <variable'>.type <> void then
        
        else
            <variable>.type := lookup(id)
        fi
    }
<variable'> ->
	\[ <expression> \]
    {
        <variable'>.type := <expression>.type
        <variable'>.val := <expression>.val
        if <expression>.type = integer then

        else
            print("type error")
            halt()
        fi
    }
	|
	ε
    {
        <variable'>.type := void
    }

<procedure_statement> ->
	call id <procedure_statement'>
<procedure_statement'> ->
	\( <expression_list> \)
	|
	ε
	
<expression_list> ->
	<expression> <expression_list'>
<expression_list'> ->
	, <expression> <expression_list'>
	|
	ε
	
<expression> ->
	<simple_expression> <expression'>
    { 
        <expression'>.in := <simple_expression>.type
        <expression>.type := <simple_expression>.type
        if <expression'>.type <> void then
            <expression>.type := <expression'>.type
        fi
    }
<expression'> ->
	relop <simple_expression>
    {
        <expresion'>.type := integer
    }
	|
	ε
    {
        <expression'>.type := void
    }
	
<simple_expression> ->
	<sign> <term> <simple_expression'> 
    {
        <simple_expression>.type := <term>.type
        <simple_expression'>.in := <term>.type
        if <simple_expression'>.type <> void then
            <simple_expression>.type := <simple_expression>.type
        fi
    }
	|
	<term> <simple_expression'>
    {
        <simple_expression>.type := <term>.type
        <simple_expression'>.in := <term>.type
        if <simple_expression'>.type <> void then
            <simple_expression>.type := <simple_expression'>.type
        fi
    }
<simple_expression'> ->
	addop <term> <simple_expression'>
    {
        if (<simple_expression'>.in = integer) and (<term>.type = integer) then
            <simple_expression'>[1].in := integer
            <simple_expression'>.type := integer
        elif (<simple_expression'>.in = integer) and (<term>.type = real) then
             <simple_expression'>[1].in := real
            <simple_expression'>.type := real
        elif (<simple_expression'>.in = real ) and (<term>.type = integer) then
             <simple_expression'>[1].in := real
            <simple_expression'>.type := real
        elif (<simple_expression'>.in = real) and (<term>.type = real) then
            <simple_expression'>[1].in := real
        else
            print(<simple_expression'>.in)
            print(<term>.type)
            print("type error")
            halt()
        fi
        if <simple_expression'>[1].type <> void then
            <simple_expression'>.type := <simple_expression'>[1].type
        fi
    }
	|
	ε
    {
        <simple_expression'>.type := void
    }


<term> ->
	<factor> <term'>
	{
        <term>.type := <factor>.type
        <term'>.in := <factor>.type
        if <term'>.type <> void then
            <term>.type := <term'>.type
        fi        
	}
<term'> ->
        mulop <factor> <term'>
        {
            if (<term'>.in = integer) and (<factor>.type = integer) then
                <term'>[1].in := integer
                <term'>.type := integer
            elif (<term'>.in = integer) and (<factor>.type = real) then
                <term'>[i].in := real
                <term'>.type := real
            elif (<term'>.in = real ) and (<factor>.type = integer) then
                <term'>[i].in := real
                <term'>.type := real
            fi
            if <term'>[1].type <> void then
                <term'>.type := <term'>[1].type
            else
                <term'>.type := <term'>.in
            fi
            

        }
        |
        ε
        {
            <term'>.type := void
        }

<factor> ->
	id <factor'>
    {
        if <factor'>.type = integer then
            <factor>.type := getarray(id)
        elif <factor'>.type = void then
            <factor>.type := lookup(id)
        else
            print("Type Error")
            halt()
        fi
    }
	|
	num
    {
        <factor>.type := num.type
        <factor>.hitnum := true
    }
	|
	\( <expression> \)
    { 
        <factor>.type := <expression>.type
    }
	|
	not <factor>
    {
        <factor>.type := <factor>[1].type
    }
    
<factor'> ->
	\[ <expression> \]
    {
        <factor'>.type := <expression>.type
        <factor'>.val := <expression>.val
    }
	|
	ε
    {
        <factor'>.type := void
    }
    
<sign> ->
	\+ | \-
