<program> ->
	program id \( <identifier_list> \) ;
	<program'>
	<compound_statement>
	\.
	{
        <bob>.derp := derp
	}        

<program'> ->
	<declarations> <dec>
	{
    }
	|
	<subprogram_declarations>
	{}
	|
	ε
	
<dec> ->
	<subprogram_declarations>
	{
        <dec>.value := (4*3*4)+40*(3*2*1)/(4-3.2)
        if <subprogram_declarations>.type = 4 then 
            <subprogram_declarations>.type := 32
        else
            <derp>.haha := 23+ not hi
        fi
                <putin>.omgnom := (4+3-3.3*321+322+(1+1))
        <factor>.type := <expression>.type 
        <factor>.type := bob(1,3,4.23+3)
        <factor>.value := <expression>.value
    }
	|
	ε

<identifier_list> ->
	id <identifier_list'>
	{
	}
<identifier_list'> ->
	, id <identifier_list'>
	{
        <identifier_list>.code := derp
	}
	|
	ε

<declarations> ->
	var id : <type> ; <declarations'>
<declarations'> ->
	var id : <type> ; <declarations'>
	|
	ε

<type> ->
	<standard_type>
	|
	array [ num \. \. num ] of <standard_type>
    {
    }

<standard_type> ->
	integer
    { <standard_type>.type := integer }
	|
	real
    { <standard_type>.type := real }
	
<subprogram_declarations> ->
	<subprogram_declaration> ; <subprogram_declarations'>
<subprogram_declarations'> ->
	<subprogram_declaration> ; <subprogram_declarations'>
	|
	ε

<subprogram_declaration> ->
	<subprogram_head>
	<subprogram_declaration'>
	<compound_statement>
<subprogram_declaration'> ->
	<declarations> <dec>
	|
	<subprogram_declarations>
	|
	ε

<subprogram_head> ->
	procedure id <subprogram_head'>;
<subprogram_head'> ->
	<arguments>
	|
	ε

<arguments> ->
	\( <parameter_list> \)
<parameter_list> ->
	id : <type> <parameter_list'>
<parameter_list'> ->
	; id : <type> <parameter_list'>
	|
	ε
	
<compound_statement> ->
	begin
	<compound_statement'>
	end
<compound_statement'> ->
	<optional_statements>
	|
	ε
	
<optional_statements> ->
	<statement_list>

<statement_list> ->
	<statement> <statement_list'>
<statement_list'> ->
	; <statement> <statement_list'>
	|
	ε

<statement> ->
	<variable> assignop <expression>
	|
	<procedure_statement>
	|
	<compound_statement>
	|
	while <expression> do <statement>
	|
	if <expression> then <statement> <statement'>
<statement'> ->
	else <statement>
	|
	ε
	
<variable> ->
	id <variable'>
<variable'> ->
	[ <expression> ]
	|
	ε

<procedure_statement> ->
	call id <procedure_statement'>
<procedure_statement'> ->
	\( <expression_list> \)
	|
	ε
	
<expression_list> ->
	<expression> <expression_list'>
<expression_list'> ->
	, <expression> <expression_list'>
	|
	ε
	
<expression> ->
	<simple_expression> <expression'>
<expression'> ->
	relop <simple_expression>
	|
	ε
	
<simple_expression> ->
	<sign> <term> <simple_expression'> 
    {
        
    }
	|
	<term> <simple_expression'>
<simple_expression'> ->
	addop <term> <simple_expression'>
    {
    }
	|
	ε

<term> ->
	<factor> <term'>
	{
		
	}
<term'> ->
	mulop <factor> <term'>
	|
	ε

<factor> ->
	id <factor'>
    {
        <putin>.omgnom := (4+3-3.3*321+322+(1+1))
        <factor>.type := <expression>.type 
        <factor>.type := bob(1,3,4.23+3)
        <factor>.value := <expression>.value
        <factor>.code := 
        "
                        if (x == 3) goto label_1;
                            fork();
                            goto label_2;
                label_1:
                        exit(1);
                label_2:
        "
    }
	|
	num
    { 
        <factor>.value := num.val
    }
	|
	\( <expression> \)
    { 
    }
	|
	not <factor>
    {
        <factor>.value := not <factor>.value
    }
<factor'> ->
	[ <expression> ]
    { <factor'>1.type := <expression>.type }
	|
	ε
    
<sign> ->
	\+ | \-
